#include "graphics.h"
#include "../console.h"
#include "../mem/heap.h"
#include "../io.h"
#include "vga.h"

static uint8_t* backbuffer = NULL;
static int graphics_active = 0;
void gfx_reset_ega_palette(void);
void gfx_reset_palette(void);

/* 8x8 bitmap font (subset: printable ASCII) */
static const uint8_t font8x8[128][8] = {
    [' '] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    ['!'] = {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},
    ['"'] = {0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    ['#'] = {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},
    ['$'] = {0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},
    ['%'] = {0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},
    ['&'] = {0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},
    ['\''] = {0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},
    ['('] = {0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},
    [')'] = {0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},
    ['*'] = {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},
    ['+'] = {0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},
    [','] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},
    ['-'] = {0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},
    ['.'] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},
    ['/'] = {0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},
    ['0'] = {0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},
    ['1'] = {0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},
    ['2'] = {0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},
    ['3'] = {0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},
    ['4'] = {0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},
    ['5'] = {0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},
    ['6'] = {0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},
    ['7'] = {0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},
    ['8'] = {0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},
    ['9'] = {0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},
    [':'] = {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},
    [';'] = {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},
    ['<'] = {0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},
    ['='] = {0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},
    ['>'] = {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},
    ['?'] = {0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},
    ['@'] = {0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},
    ['A'] = {0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},
    ['B'] = {0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},
    ['C'] = {0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},
    ['D'] = {0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},
    ['E'] = {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},
    ['F'] = {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},
    ['G'] = {0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},
    ['H'] = {0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},
    ['I'] = {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},
    ['J'] = {0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},
    ['K'] = {0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},
    ['L'] = {0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},
    ['M'] = {0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},
    ['N'] = {0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},
    ['O'] = {0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},
    ['P'] = {0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},
    ['Q'] = {0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},
    ['R'] = {0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},
    ['S'] = {0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},
    ['T'] = {0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},
    ['U'] = {0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},
    ['V'] = {0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},
    ['W'] = {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},
    ['X'] = {0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},
    ['Y'] = {0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},
    ['Z'] = {0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},
    ['['] = {0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},
    ['\\'] = {0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},
    [']'] = {0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},
    ['^'] = {0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},
    ['_'] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
    ['`'] = {0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
    ['a'] = {0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},
    ['b'] = {0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},
    ['c'] = {0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},
    ['d'] = {0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},
    ['e'] = {0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},
    ['f'] = {0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},
    ['g'] = {0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},
    ['h'] = {0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},
    ['i'] = {0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},
    ['j'] = {0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},
    ['k'] = {0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},
    ['l'] = {0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},
    ['m'] = {0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},
    ['n'] = {0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},
    ['o'] = {0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},
    ['p'] = {0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},
    ['q'] = {0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},
    ['r'] = {0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},
    ['s'] = {0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},
    ['t'] = {0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},
    ['u'] = {0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},
    ['v'] = {0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},
    ['w'] = {0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},
    ['x'] = {0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},
    ['y'] = {0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},
    ['z'] = {0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},
    ['{'] = {0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},
    ['|'] = {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},
    ['}'] = {0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},
    ['~'] = {0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

void gfx_init(void) {
    if (!backbuffer) {
        backbuffer = kmalloc(GFX_WIDTH * GFX_HEIGHT);
        if (!backbuffer) {
            printf("Graphics: Failed to allocate backbuffer\n");
            return;
        }
    }
    memset_s(backbuffer, 0, GFX_WIDTH * GFX_HEIGHT);
}

void gfx_enter_mode(void) {
    // Prostsze ustawienie trybu 13h
    outb(0x3C2, 0x63); // Misc Output

    // Sekwencer
    outb(0x3C4, 0x00); outb(0x3C5, 0x01); // Reset
    outb(0x3C4, 0x01); outb(0x3C5, 0x01); // Clocking Mode
    outb(0x3C4, 0x02); outb(0x3C5, 0x0F); // Map Mask
    outb(0x3C4, 0x03); outb(0x3C5, 0x00); // Character Map
    outb(0x3C4, 0x04); outb(0x3C5, 0x02); // Memory Mode
    outb(0x3C4, 0x00); outb(0x3C5, 0x03); // End Reset

    // CRTC
    outb(0x3D4, 0x11); outb(0x3D5, inb(0x3D5) & 0x7F); // Odblokuj CRTC
    outb(0x3D4, 0x00); outb(0x3D5, 0x5F);
    outb(0x3D4, 0x01); outb(0x3D5, 0x4F);
    outb(0x3D4, 0x02); outb(0x3D5, 0x50);
    outb(0x3D4, 0x03); outb(0x3D5, 0x82);
    outb(0x3D4, 0x04); outb(0x3D5, 0x54);
    outb(0x3D4, 0x05); outb(0x3D5, 0x80);
    outb(0x3D4, 0x06); outb(0x3D5, 0xBF);
    outb(0x3D4, 0x07); outb(0x3D5, 0x1F);
    outb(0x3D4, 0x08); outb(0x3D5, 0x00);
    outb(0x3D4, 0x09); outb(0x3D5, 0x41);
    outb(0x3D4, 0x10); outb(0x3D5, 0x9C);
    outb(0x3D4, 0x11); outb(0x3D5, 0x8E);
    outb(0x3D4, 0x12); outb(0x3D5, 0x8F);
    outb(0x3D4, 0x13); outb(0x3D5, 0x28);
    outb(0x3D4, 0x14); outb(0x3D5, 0x40);
    outb(0x3D4, 0x15); outb(0x3D5, 0x96);
    outb(0x3D4, 0x16); outb(0x3D5, 0xB9);
    outb(0x3D4, 0x17); outb(0x3D5, 0xA3);

    // Graphics Controller
    outb(0x3CE, 0x05); outb(0x3CF, 0x40); // Graphics Mode
    outb(0x3CE, 0x06); outb(0x3CF, 0x05); // Memory Map

    // Attribute Controller
    (void)inb(0x3DA); // Reset flip-flop
    outb(0x3C0, 0x10); outb(0x3C0, 0x41); // Mode Control
    outb(0x3C0, 0x13); outb(0x3C0, 0x00); // Pixel Panning
    outb(0x3C0, 0x20); // End

    graphics_active = 1;
    gfx_init();
    /* gfx_reset_palette();
    gfx_clear(COLOR_BLACK); */
    memset_s(GFX_VRAM, COLOR_BLACK, GFX_WIDTH * GFX_HEIGHT);
}

void gfx_exit_mode(void) {
    // Prostsze ustawienie trybu tekstowego 80x25
    outb(0x3C2, 0x67); // Misc Output

    // Sekwencer
    outb(0x3C4, 0x00); outb(0x3C5, 0x01); // Reset
    outb(0x3C4, 0x01); outb(0x3C5, 0x01); // Clocking Mode
    outb(0x3C4, 0x02); outb(0x3C5, 0x03); // Map Mask
    outb(0x3C4, 0x03); outb(0x3C5, 0x00); // Character Map
    outb(0x3C4, 0x04); outb(0x3C5, 0x02); // Memory Mode
    outb(0x3C4, 0x00); outb(0x3C5, 0x03); // End Reset

    // CRTC
    outb(0x3D4, 0x11); outb(0x3D5, inb(0x3D5) & 0x7F); // Odblokuj CRTC
    outb(0x3D4, 0x00); outb(0x3D5, 0x5F);
    outb(0x3D4, 0x01); outb(0x3D5, 0x4F);
    outb(0x3D4, 0x02); outb(0x3D5, 0x50);
    outb(0x3D4, 0x03); outb(0x3D5, 0x82);
    outb(0x3D4, 0x04); outb(0x3D5, 0x55);
    outb(0x3D4, 0x05); outb(0x3D5, 0x81);
    outb(0x3D4, 0x06); outb(0x3D5, 0xBF);
    outb(0x3D4, 0x07); outb(0x3D5, 0x1F);
    outb(0x3D4, 0x08); outb(0x3D5, 0x00);
    outb(0x3D4, 0x09); outb(0x3D5, 0x4F);
    outb(0x3D4, 0x10); outb(0x3D5, 0x9C);
    outb(0x3D4, 0x11); outb(0x3D5, 0x8E);
    outb(0x3D4, 0x12); outb(0x3D5, 0x8F);
    outb(0x3D4, 0x13); outb(0x3D5, 0x28);
    outb(0x3D4, 0x14); outb(0x3D5, 0x1F);
    outb(0x3D4, 0x15); outb(0x3D5, 0x96);
    outb(0x3D4, 0x16); outb(0x3D5, 0xB9);
    outb(0x3D4, 0x17); outb(0x3D5, 0xA3);

    // Graphics Controller
    outb(0x3CE, 0x05); outb(0x3CF, 0x10); // Graphics Mode (text)
    outb(0x3CE, 0x06); outb(0x3CF, 0x0E); // Memory Map (text)

    // Attribute Controller
    (void)inb(0x3DA); // Reset flip-flop
    for (uint8_t i = 0; i < 16; i++) {
        outb(0x3C0, i);
        outb(0x3C0, i);
    }
    outb(0x3C0, 0x10); outb(0x3C0, 0x0C); // Mode Control (text)
    outb(0x3C0, 0x13); outb(0x3C0, 0x08); // Pixel Panning
    outb(0x3C0, 0x20); // End

    graphics_active = 0;

    // Wyczyść ekran tekstowy
    vga_set_color(0,7);
    vga_clear();
}

int gfx_is_active(void) {
    return graphics_active;
}

void gfx_clear(uint8_t color) {
    if (!backbuffer) return;
    memset_s(backbuffer, color, GFX_WIDTH * GFX_HEIGHT);
}

void gfx_swap_buffers(void) {
    if (!backbuffer) return;
    
    // Bezpośrednie kopiowanie
    uint8_t* vram = GFX_VRAM;
    for (int i = 0; i < GFX_WIDTH * GFX_HEIGHT; i++) {
        vram[i] = backbuffer[i];
    }
}

void gfx_putpixel_direct(int x, int y, uint8_t color) {
    if (x < 0 || x >= GFX_WIDTH || y < 0 || y >= GFX_HEIGHT) return;
    
    // W trybie 13h nie potrzebujemy ustawiać map mask - bezpośredni zapis
    GFX_VRAM[y * GFX_WIDTH + x] = color;
}

uint8_t* gfx_get_backbuffer(void) {
    return backbuffer;
}

void gfx_putpixel(int x, int y, uint8_t color) {
    if (!backbuffer) return;
    if (x < 0 || x >= GFX_WIDTH || y < 0 || y >= GFX_HEIGHT) return;
    backbuffer[y * GFX_WIDTH + x] = color;
}

uint8_t gfx_getpixel(int x, int y) {
    if (!backbuffer) return 0;
    if (x < 0 || x >= GFX_WIDTH || y < 0 || y >= GFX_HEIGHT) return 0;
    return backbuffer[y * GFX_WIDTH + x];
}

void gfx_line(int x0, int y0, int x1, int y1, uint8_t color) {
    /* Bresenham's line algorithm */
    int dx = x1 - x0;
    int dy = y1 - y0;
    
    if (dx < 0) dx = -dx;
    if (dy < 0) dy = -dy;
    
    int sx = x0 < x1 ? 1 : -1;
    int sy = y0 < y1 ? 1 : -1;
    int err = dx - dy;
    
    while (1) {
        gfx_putpixel(x0, y0, color);
        
        if (x0 == x1 && y0 == y1) break;
        
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
}

void gfx_rect(int x, int y, int w, int h, uint8_t color) {
    gfx_line(x, y, x + w - 1, y, color);
    gfx_line(x + w - 1, y, x + w - 1, y + h - 1, color);
    gfx_line(x + w - 1, y + h - 1, x, y + h - 1, color);
    gfx_line(x, y + h - 1, x, y, color);
}

void gfx_fillrect(int x, int y, int w, int h, uint8_t color) {
    for (int dy = 0; dy < h; dy++) {
        for (int dx = 0; dx < w; dx++) {
            gfx_putpixel(x + dx, y + dy, color);
        }
    }
}

void gfx_circle(int cx, int cy, int r, uint8_t color) {
    /* Midpoint circle algorithm */
    int x = r;
    int y = 0;
    int err = 0;
    
    while (x >= y) {
        gfx_putpixel(cx + x, cy + y, color);
        gfx_putpixel(cx + y, cy + x, color);
        gfx_putpixel(cx - y, cy + x, color);
        gfx_putpixel(cx - x, cy + y, color);
        gfx_putpixel(cx - x, cy - y, color);
        gfx_putpixel(cx - y, cy - x, color);
        gfx_putpixel(cx + y, cy - x, color);
        gfx_putpixel(cx + x, cy - y, color);
        
        if (err <= 0) {
            y += 1;
            err += 2*y + 1;
        }
        
        if (err > 0) {
            x -= 1;
            err -= 2*x + 1;
        }
    }
}

void gfx_putchar(int x, int y, char c, uint8_t fg, uint8_t bg) {
    if (c < 0 || c >= 127) return;
    
    const uint8_t* glyph = font8x8[(unsigned char)c];
    
    for (int row = 0; row < 8; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < 8; col++) {
            uint8_t color = (bits & (1 << (7 - col))) ? fg : bg;
            gfx_putpixel(x + col, y + row, color);
        }
    }
}

void gfx_print(int x, int y, const char* str, uint8_t fg, uint8_t bg) {
    int cx = x;
    int cy = y;
    
    while (*str) {
        if (*str == '\n') {
            cx = x;
            cy += 8;
        } else {
            gfx_putchar(cx, cy, *str, fg, bg);
            cx += 8;
            if (cx >= GFX_WIDTH) {
                cx = x;
                cy += 8;
            }
        }
        str++;
    }
}

void gfx_set_palette(uint8_t index, uint8_t r, uint8_t g, uint8_t b) {
    outb(0x3C8, index);
    outb(0x3C9, r >> 2);
    outb(0x3C9, g >> 2);
    outb(0x3C9, b >> 2);
}

void gfx_get_palette(uint8_t index, uint8_t* r, uint8_t* g, uint8_t* b) {
    outb(0x3C7, index);
    *r = inb(0x3C9) << 2;
    *g = inb(0x3C9) << 2;
    *b = inb(0x3C9) << 2;
}

void gfx_reset_palette(void) {
    // Prosta paleta VGA
    for (int i = 0; i < 256; i++) {
        outb(0x3C8, i);
        outb(0x3C9, (i >> 2) & 0x3F);
        outb(0x3C9, (i >> 4) & 0x3F);
        outb(0x3C9, (i >> 6) & 0x3F);
    }
}

void gfx_reset_ega_palette(void) {
    // Standardowa paleta EGA (16 kolorów)
    static const uint8_t ega_colors[16][3] = {
        {0x00, 0x00, 0x00}, // 0: Black
        {0x00, 0x00, 0xAA}, // 1: Blue
        {0x00, 0xAA, 0x00}, // 2: Green
        {0x00, 0xAA, 0xAA}, // 3: Cyan
        {0xAA, 0x00, 0x00}, // 4: Red
        {0xAA, 0x00, 0xAA}, // 5: Magenta
        {0xAA, 0x55, 0x00}, // 6: Brown
        {0xAA, 0xAA, 0xAA}, // 7: Light Gray
        {0x55, 0x55, 0x55}, // 8: Dark Gray
        {0x55, 0x55, 0xFF}, // 9: Light Blue
        {0x55, 0xFF, 0x55}, // 10: Light Green
        {0x55, 0xFF, 0xFF}, // 11: Light Cyan
        {0xFF, 0x55, 0x55}, // 12: Light Red
        {0xFF, 0x55, 0xFF}, // 13: Light Magenta
        {0xFF, 0xFF, 0x55}, // 14: Yellow
        {0xFF, 0xFF, 0xFF}  // 15: White
    };
    
    for (int i = 0; i < 16; i++) {
        outb(0x3C8, i);
        outb(0x3C9, ega_colors[i][0] >> 2);
        outb(0x3C9, ega_colors[i][1] >> 2);
        outb(0x3C9, ega_colors[i][2] >> 2);
    }
}