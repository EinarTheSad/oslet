<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>osLET IDE - Multi-Window Form Designer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Liberation+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Liberation Sans', 'Arial', sans-serif;
            background: #2b2b2b;
            color: #e0e0e0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 250px;
            background: #1e1e1e;
            border-right: 1px solid #3e3e3e;
            display: flex;
            flex-direction: column;
        }

        #project-header {
            padding: 15px;
            border-bottom: 1px solid #3e3e3e;
        }

        #project-name {
            font-size: 14px;
            font-weight: bold;
            color: #007acc;
            margin-bottom: 10px;
        }

        .project-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .project-actions button {
            flex: 1;
            min-width: 70px;
            font-size: 11px;
            padding: 5px 8px;
        }

        #windows-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .window-item {
            background: #2d2d2d;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .window-item:hover {
            background: #3d3d3d;
        }

        .window-item.active {
            border-color: #007acc;
            background: #1e3a5f;
        }

        .window-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .window-item-title {
            font-weight: bold;
            font-size: 13px;
        }

        .window-item-info {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }

        .window-delete {
            background: #c00;
            color: white;
            border: none;
            padding: 3px 8px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 3px;
        }

        .window-delete:hover {
            background: #e00;
        }

        #add-window-btn {
            margin: 10px;
            background: #007acc;
            color: white;
            border: none;
            padding: 10px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 4px;
        }

        #add-window-btn:hover {
            background: #005a9e;
        }

        #toolbar {
            width: 200px;
            background: #1e1e1e;
            padding: 15px;
            border-right: 1px solid #3e3e3e;
            overflow-y: auto;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #2b2b2b;
        }

        #top-bar {
            background: #1e1e1e;
            padding: 10px 15px;
            border-bottom: 1px solid #3e3e3e;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        #canvas {
            flex: 1;
            position: relative;
            overflow: auto;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #screen-bounds {
            width: 640px;
            height: 480px;
            background: #008080;
            border: 1px solid #666666;
            position: relative;
        }

        #form {
            position: absolute;
            box-sizing: border-box;
        }

        #form::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid #555555;
            pointer-events: none;
            z-index: 1;
        }

        #form::after {
            content: '';
            position: absolute;
            top: 1px;
            left: 1px;
            right: 1px;
            bottom: 1px;
            border: 1px solid #a0a0a0;
            pointer-events: none;
            z-index: 1;
        }

        #titlebar {
            position: absolute;
            left: 2px;
            top: 2px;
            height: 18px;
            background: #1e1e64;
            cursor: move;
            display: flex;
            align-items: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
            user-select: none;
            letter-spacing: 1.2px;
            z-index: 2;
        }

        #form-title {
            padding-left: 5px;
            line-height: 18px;
        }

        #close-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 14px;
            height: 14px;
            background: #a0a0a0;
            cursor: default;
            box-sizing: border-box;
        }
        
        #close-btn::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            width: 16px;
            height: 16px;
            border: 1px solid #555555;
            pointer-events: none;
            box-sizing: border-box;
        }
        
        #close-btn::after {
            content: '';
            width: 10px;
            height: 2px;
            background: white;
            position: absolute;
            left: 2px;
            top: 6px;
        }

        #form-content {
            position: absolute;
            left: 2px;
            top: 20px;
            background: #ffffff;
            overflow: hidden;
        }

        .resize-handle {
            position: absolute;
            background: transparent;
            z-index: 100;
        }

        .resize-handle.corner {
            width: 10px;
            height: 10px;
            cursor: nwse-resize;
        }

        .resize-handle.right {
            width: 5px;
            height: 100%;
            right: 0;
            top: 0;
            cursor: ew-resize;
        }

        .resize-handle.bottom {
            width: 100%;
            height: 5px;
            bottom: 0;
            left: 0;
            cursor: ns-resize;
        }

        .resize-handle.corner.br {
            right: 0;
            bottom: 0;
        }

        .control {
            position: absolute;
            cursor: move;
            border: 1px dashed transparent;
        }

        .control.selected {
            border: 1px dashed #ffa500;
            outline: 1px solid #ffa500;
        }

        .control-button {
            background: #a0a0a0;
            border: 1px solid #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            user-select: none;
            color: #000;
            box-sizing: border-box;
            letter-spacing: 1px;
        }

        .control-button::after {
            content: '';
            position: absolute;
            top: 0px;
            left: 0px;
            right: 0px;
            bottom: 0px;
            border: 1px solid;
            border-top-color: #ffffff;
            border-left-color: #ffffff;
            border-right-color: #555555;
            border-bottom-color: #555555;
            pointer-events: none;
        }

        .control-resize-handle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffa500;
            border: 1px solid #000;
            z-index: 10;
        }

        .control-resize-handle.br {
            right: -3px;
            bottom: -3px;
            cursor: nwse-resize;
        }

        .control-label {
            font-size: 12px;
            user-select: none;
            white-space: pre;
            padding: 2px;
            box-sizing: border-box;
            display: inline-block;
            line-height: 1.2;
            letter-spacing: 1px;
        }

        .control-picturebox {
            background: #555;
            border: 1px solid #a0a0a0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 10px;
        }

        .control-dropdown {
            background: white;
            display: flex;
            align-items: stretch;
            font-size: 12px;
            user-select: none;
            box-sizing: border-box;
        }

        .control-dropdown .dropdown-field {
            flex: 1;
            padding: 3px 4px;
            border-top: 1px solid #808080;
            border-left: 1px solid #808080;
            border-bottom: 1px solid #dfdfdf;
            border-right: none;
            box-shadow: inset 1px 1px 0 #404040;
            overflow: hidden;
            white-space: nowrap;
        }

        .control-dropdown .dropdown-btn {
            width: 16px;
            background: #a0a0a0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #000;
            box-sizing: border-box;
        }

        .control-dropdown .dropdown-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid;
            border-top-color: #ffffff;
            border-left-color: #ffffff;
            border-right-color: #555555;
            border-bottom-color: #555555;
            pointer-events: none;
        }

        .control-dropdown .dropdown-arrow {
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid black;
        }

        #properties {
            width: 250px;
            background: #1e1e1e;
            padding: 15px;
            border-left: 1px solid #3e3e3e;
            overflow-y: auto;
        }

        .tool-btn {
            background: #3e3e3e;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 8px 12px;
            margin-bottom: 8px;
            cursor: pointer;
            width: 100%;
            text-align: left;
            transition: background 0.2s;
        }

        .tool-btn:hover {
            background: #4e4e4e;
        }

        .tool-btn.active {
            background: #007acc;
            border-color: #007acc;
        }

        .prop-group {
            margin-bottom: 15px;
        }

        .prop-label {
            font-size: 11px;
            color: #999;
            margin-bottom: 4px;
        }

        .prop-input {
            width: 100%;
            background: #3e3e3e;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 6px;
            font-size: 12px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        textarea.prop-input {
            resize: vertical;
            min-height: 60px;
        }

        button {
            background: #007acc;
            border: none;
            color: white;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
            font-size: 12px;
        }

        button:hover {
            background: #005a9e;
        }

        h3 {
            color: #007acc;
            font-size: 14px;
            margin-bottom: 10px;
            border-bottom: 1px solid #3e3e3e;
            padding-bottom: 5px;
        }

        #code-output {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1e1e1e;
            border: 2px solid #007acc;
            padding: 20px;
            max-width: 800px;
            max-height: 80vh;
            overflow: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        #code-output.show {
            display: block;
        }

        pre {
            background: #2b2b2b;
            padding: 15px;
            overflow-x: auto;
            color: #d4d4d4;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .close-btn {
            background: #c00;
            padding: 4px 12px;
            font-size: 12px;
            margin-left: 10px;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin-top: 4px;
        }

        .color-btn {
            width: 100%;
            height: 30px;
            border: 2px solid #555;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .color-btn:hover {
            transform: scale(1.1);
            border-color: #ffa500;
        }

        .color-btn.selected {
            border-color: #ffa500;
            border-width: 3px;
        }

        #no-window-message {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            font-size: 18px;
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div id="project-header">
            <div id="project-name">Untitled Project</div>
            <div class="project-actions">
                <button onclick="newProject()" title="New Project">New</button>
                <button onclick="saveProject()" title="Save Project">Save</button>
                <button onclick="loadProject()" title="Load Project">Load</button>
                <button onclick="importCFile()" title="Import C File">Import C</button>
                <button onclick="generateCode()" title="Generate C Code">Build</button>
                <button onclick="openCodeEditor()" title="Edit Global Code" style="background: #5a5;">Code</button>
            </div>
        </div>

        <div id="windows-list">
            <!-- Window items will be added here -->
        </div>

        <button id="add-window-btn" onclick="addWindow()">+ Add Window</button>
    </div>

    <div id="toolbar">
        <h3>Toolbox</h3>
        <button class="tool-btn" onclick="selectTool('button')">Button</button>
        <button class="tool-btn" onclick="selectTool('label')">Label</button>
        <button class="tool-btn" onclick="selectTool('picturebox')">PictureBox</button>
        <button class="tool-btn" onclick="selectTool('checkbox')">CheckBox</button>
        <button class="tool-btn" onclick="selectTool('radiobutton')">RadioButton</button>
        <button class="tool-btn" onclick="selectTool('textbox')">TextBox</button>
        <button class="tool-btn" onclick="selectTool('frame')">Frame</button>
        <button class="tool-btn" onclick="selectTool('dropdown')">Dropdown</button>
        <button class="tool-btn" onclick="selectTool('scrollbar')">ScrollBar</button>
        <button class="tool-btn" onclick="selectTool('select')" style="margin-top: 20px;">Select (Esc)</button>
    </div>

    <div id="canvas-container">
        <div id="top-bar">
            <button onclick="undo()" id="undo-btn" title="Undo (Ctrl+Z)">Undo</button>
            <button onclick="redo()" id="redo-btn" title="Redo (Ctrl+Y)">Redo</button>
            <button onclick="deleteSelected()" style="background: #c00;">Delete Control</button>
            <button onclick="clearAllControls()" style="background: #c00;">Clear All Controls</button>

            <div id="grid-controls" style="display:inline-block; margin-left: 12px; vertical-align: middle;">
                <label style="font-size:12px; color:#ccc; margin-right:6px;">Grid:</label>
                <input id="grid-size-input" type="number" min="2" max="64" step="1" value="8" style="width:64px; margin-right:8px;"> 
                <label style="color:#ccc; margin-right:8px;"><input id="snap-checkbox" type="checkbox" checked> Snap</label>
                <label style="color:#ccc;"><input id="show-grid-checkbox" type="checkbox" checked> Show Grid</label>
            </div>
        </div>

        <div id="canvas">
            <div id="no-window-message">
                Create or select a window to start designing
            </div>
            <div id="screen-bounds" style="display: none;">
                <div id="form">
                    <div id="form-content"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="properties">
        <h3>Properties</h3>
        <div id="prop-content">
            <p style="color: #666; font-size: 12px;">No window selected</p>
        </div>
    </div>

    <div id="code-output">
        <h3>Generated Code</h3>
        <button onclick="copyCode()" style="margin-bottom: 10px;">Copy to Clipboard</button>
        <button onclick="saveCodeToFile()" style="margin-bottom: 10px;">Save as .c</button>
        <button onclick="closeCodeWindow()" class="close-btn">Close</button>
        <pre id="code-text"></pre>
    </div>

    <!-- Code Editor Modal for globals and helpers -->
    <div id="code-editor-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
         background: rgba(0,0,0,0.8); z-index: 1000; padding: 30px;">
        <div style="background: #1e1e1e; border-radius: 8px; max-width: 900px; margin: 0 auto; height: calc(100% - 60px);
                    display: flex; flex-direction: column;">
            <div style="padding: 15px; border-bottom: 1px solid #3e3e3e; display: flex; justify-content: space-between; align-items: center;">
                <h3 style="margin: 0;">Project Code Editor</h3>
                <button onclick="closeCodeEditor()" class="close-btn">Close</button>
            </div>
            <div style="flex: 1; display: flex; overflow: hidden;">
                <!-- Globals panel -->
                <div style="flex: 1; display: flex; flex-direction: column; border-right: 1px solid #3e3e3e;">
                    <div style="padding: 10px; background: #2a2a2a; border-bottom: 1px solid #3e3e3e;">
                        <strong>Global Variables</strong>
                        <div style="font-size: 10px; color: #888; margin-top: 3px;">Static variables, state, constants</div>
                    </div>
                    <textarea id="globals-editor" style="flex: 1; background: #1e1e1e; color: #e0e0e0; border: none;
                              font-family: monospace; font-size: 12px; padding: 10px; resize: none;"
                              placeholder="/* Global variables */&#10;static int counter = 0;&#10;static char buffer[256];"></textarea>
                </div>
                <!-- Helpers panel -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <div style="padding: 10px; background: #2a2a2a; border-bottom: 1px solid #3e3e3e;">
                        <strong>Helper Functions</strong>
                        <div style="font-size: 10px; color: #888; margin-top: 3px;">Functions called from button actions</div>
                    </div>
                    <textarea id="helpers-editor" style="flex: 1; background: #1e1e1e; color: #e0e0e0; border: none;
                              font-family: monospace; font-size: 12px; padding: 10px; resize: none;"
                              placeholder="/* Helper functions */&#10;static void update_display(void *form, int val) {&#10;    char buf[16];&#10;    // ...&#10;}"></textarea>
                </div>
            </div>
            <div style="padding: 10px; border-top: 1px solid #3e3e3e; text-align: right;">
                <button onclick="saveCodeEditor()" style="background: #007acc; padding: 8px 20px;">Save</button>
                <button onclick="closeCodeEditor()" style="margin-left: 10px;">Cancel</button>
            </div>
        </div>
    </div>

    <input type="file" id="project-file-input" accept=".oplet" onchange="handleProjectLoad(event)">
    <input type="file" id="c-file-input" accept=".c" onchange="handleCFileLoad(event)">

    <script>
        const osletColors = [
            {name: 'BLACK', val: 0, rgb: '#000000'},
            {name: 'BLUE', val: 1, rgb: '#1e1e64'},
            {name: 'GREEN', val: 2, rgb: '#346524'},
            {name: 'CYAN', val: 3, rgb: '#4095aa'},
            {name: 'RED', val: 4, rgb: '#643c18'},
            {name: 'MAGENTA', val: 5, rgb: '#462337'},
            {name: 'BROWN', val: 6, rgb: '#646418'},
            {name: 'LIGHT_GRAY', val: 7, rgb: '#a0a0a0'},
            {name: 'DARK_GRAY', val: 8, rgb: '#555555'},
            {name: 'LIGHT_BLUE', val: 9, rgb: '#597dce'},
            {name: 'LIGHT_GREEN', val: 10, rgb: '#6daa2c'},
            {name: 'LIGHT_CYAN', val: 11, rgb: '#6eced8'},
            {name: 'LIGHT_RED', val: 12, rgb: '#d04648'},
            {name: 'LIGHT_MAGENTA', val: 13, rgb: '#d2aa99'},
            {name: 'YELLOW', val: 14, rgb: '#e6dc42'},
            {name: 'WHITE', val: 15, rgb: '#ffffff'}
        ];

        // Project state
        let project = {
            name: 'Untitled Project',
            windows: [],
            globals: '',       // Global variables (e.g., static int counter = 0;)
            helpers: '',       // Helper functions (e.g., void append_digit(...) { ... })
            grid: { size: 8, snap: true, show: true }
        };

        let currentWindowIndex = -1;
        let currentTool = 'select';
        let selectedControl = null;
        let nextId = 1;

        // Grid and snapping
        let gridSize = project.grid.size || 8;
        let snapToGrid = project.grid.snap === undefined ? true : project.grid.snap;
        let showGrid = project.grid.show === undefined ? true : project.grid.show;

        function updateGridBackground() {
            if (!getCurrentWindow()) return;
            if (!showGrid) {
                formContent.style.backgroundImage = 'none';
                return;
            }
            const size = Math.max(2, Math.floor(gridSize));
            // Light grid lines using two linear-gradients
            formContent.style.backgroundImage = `linear-gradient(to right, rgba(0,0,0,0.06) 1px, transparent 1px), linear-gradient(to bottom, rgba(0,0,0,0.06) 1px, transparent 1px)`;
            formContent.style.backgroundSize = `${size}px ${size}px, ${size}px ${size}px`;
        }

        function setGridFromUI() {
            const input = document.getElementById('grid-size-input');
            const snap = document.getElementById('snap-checkbox');
            const show = document.getElementById('show-grid-checkbox');
            if (input) { gridSize = Math.max(2, parseInt(input.value) || 8); }
            if (snap) { snapToGrid = snap.checked; }
            if (show) { showGrid = show.checked; }
            project.grid.size = gridSize;
            project.grid.snap = snapToGrid;
            project.grid.show = showGrid;
            updateGridBackground();
        }

        // Undo/Redo state
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50;
        let draggedControl = null;
        let dragOffset = {x: 0, y: 0};
        let formDragging = false;
        let formDragOffset = {x: 0, y: 0};
        let resizing = false;
        let resizeType = '';
        let resizeStart = {x: 0, y: 0, w: 0, h: 0};
        let resizingControl = false;
        let resizeControlStart = {x: 0, y: 0, w: 0, h: 0};

        const fontNames = ['Normal', 'Bold', 'Italic', 'Bold Italic'];

        const form = document.getElementById('form');
        const formContent = document.getElementById('form-content');
        const canvas = document.getElementById('canvas');
        const screenBounds = document.getElementById('screen-bounds');
        const noWindowMessage = document.getElementById('no-window-message');

        // Create titlebar
        const titlebar = document.createElement('div');
        titlebar.id = 'titlebar';
        const formTitle = document.createElement('span');
        formTitle.id = 'form-title';
        formTitle.textContent = 'Window1';
        titlebar.appendChild(formTitle);

        const closeBtn = document.createElement('div');
        closeBtn.id = 'close-btn';
        titlebar.appendChild(closeBtn);

        form.appendChild(titlebar);

        // Create resize handles
        const resizeRight = document.createElement('div');
        resizeRight.className = 'resize-handle right';
        const resizeBottom = document.createElement('div');
        resizeBottom.className = 'resize-handle bottom';
        const resizeCorner = document.createElement('div');
        resizeCorner.className = 'resize-handle corner br';

        form.appendChild(resizeRight);
        form.appendChild(resizeBottom);
        form.appendChild(resizeCorner);

        function getCurrentWindow() {
            if (currentWindowIndex >= 0 && currentWindowIndex < project.windows.length) {
                return project.windows[currentWindowIndex];
            }
            return null;
        }

        function newProject() {
            if (project.windows.length > 0) {
                if (!confirm('Create new project? Current work will be lost if not saved.')) {
                    return;
                }
            }

            project = {
                name: 'Untitled Project',
                windows: [],
                globals: '',
                helpers: '',
                grid: { size: 8, snap: true, show: true }
            };
            currentWindowIndex = -1;
            nextId = 1;

            document.getElementById('project-name').textContent = project.name;
            updateWindowsList();
            hideCanvas();
            updateProperties();
        }

        function addWindow() {
            const defaultName = `Form${project.windows.length + 1}`;
            const name = prompt('Window name:', defaultName);
            if (!name) return;

            const win = {
                name: name,
                title: name,
                icon: '',
                x: 50 + (project.windows.length * 20),
                y: 50 + (project.windows.length * 20),
                w: 320,
                h: 240,
                controls: [],
                nextControlId: 1
            };

            project.windows.push(win);
            updateWindowsList();
            selectWindow(project.windows.length - 1);
        }

        function saveUndoState() {
            const win = getCurrentWindow();
            if (!win) return;

            // Create a deep copy of the current window state
            const state = {
                windowIndex: currentWindowIndex,
                controls: JSON.parse(JSON.stringify(win.controls.map(c => ({
                    type: c.type,
                    x: c.x,
                    y: c.y,
                    w: c.w,
                    h: c.h,
                    fg: c.fg,
                    bg: c.bg,
                    text: c.text,
                    id: c.id,
                    font_type: c.font_type,
                    font_size: c.font_size,
                    border: c.border,
                    border_color: c.border_color,
                    checked: c.checked,
                    group_id: c.group_id,
                    max_length: c.max_length,
                    action: c.action
                })))),
                nextControlId: win.nextControlId
            };

            undoStack.push(state);
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }

            // Clear redo stack when new action is performed
            redoStack = [];
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length === 0) return;

            const win = getCurrentWindow();
            if (!win) return;

            // Save current state to redo stack
            const currentState = {
                windowIndex: currentWindowIndex,
                controls: JSON.parse(JSON.stringify(win.controls.map(c => ({
                    type: c.type,
                    x: c.x,
                    y: c.y,
                    w: c.w,
                    h: c.h,
                    fg: c.fg,
                    bg: c.bg,
                    text: c.text,
                    id: c.id,
                    font_type: c.font_type,
                    font_size: c.font_size,
                    border: c.border,
                    border_color: c.border_color,
                    checked: c.checked,
                    group_id: c.group_id,
                    max_length: c.max_length,
                    action: c.action
                })))),
                nextControlId: win.nextControlId
            };
            redoStack.push(currentState);

            // Restore previous state
            const previousState = undoStack.pop();
            restoreState(previousState);
            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;

            const win = getCurrentWindow();
            if (!win) return;

            // Save current state to undo stack
            const currentState = {
                windowIndex: currentWindowIndex,
                controls: JSON.parse(JSON.stringify(win.controls.map(c => ({
                    type: c.type,
                    x: c.x,
                    y: c.y,
                    w: c.w,
                    h: c.h,
                    fg: c.fg,
                    bg: c.bg,
                    text: c.text,
                    id: c.id,
                    font_type: c.font_type,
                    font_size: c.font_size,
                    border: c.border,
                    border_color: c.border_color,
                    checked: c.checked,
                    group_id: c.group_id,
                    max_length: c.max_length,
                    action: c.action
                })))),
                nextControlId: win.nextControlId
            };
            undoStack.push(currentState);

            // Restore next state
            const nextState = redoStack.pop();
            restoreState(nextState);
            updateUndoRedoButtons();
        }

        function restoreState(state) {
            const win = getCurrentWindow();
            if (!win) return;

            // Clear current controls from DOM
            win.controls.forEach(c => {
                if (c.el) c.el.remove();
            });

            // Restore controls
            win.controls = state.controls.map(c => ({...c}));
            win.nextControlId = state.nextControlId;

            // Recreate DOM elements
            win.controls.forEach(control => {
                createControlElement(control, win);
            });

            selectedControl = null;
            updateProperties();
            updateWindowsList();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');

            if (undoBtn) {
                undoBtn.disabled = undoStack.length === 0;
                undoBtn.style.opacity = undoStack.length === 0 ? '0.5' : '1';
            }

            if (redoBtn) {
                redoBtn.disabled = redoStack.length === 0;
                redoBtn.style.opacity = redoStack.length === 0 ? '0.5' : '1';
            }
        }

        function selectWindow(index) {
            // Save current window state if exists
            if (currentWindowIndex >= 0) {
                saveCurrentWindowState();
            }

            currentWindowIndex = index;
            const win = getCurrentWindow();

            if (!win) {
                hideCanvas();
                return;
            }

            // Clear undo/redo stacks when switching windows
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();

            // Show canvas
            showCanvas();

            // Load window state
            loadWindowState(win);

            updateWindowsList();
            updateProperties();
        }

        function saveCurrentWindowState() {
            const win = getCurrentWindow();
            if (!win) return;

            // Save form position and size
            win.x = parseInt(form.style.left) || win.x;
            win.y = parseInt(form.style.top) || win.y;

            // Controls are already saved in the win.controls array (kept in sync)
        }

        function loadWindowState(win) {
            // Clear current controls from DOM
            formContent.innerHTML = '';

            // Set form dimensions
            form.style.width = win.w + 'px';
            form.style.height = win.h + 'px';
            form.style.left = win.x + 'px';
            form.style.top = win.y + 'px';

            formTitle.textContent = win.title;

            const titlebarEl = document.getElementById('titlebar');
            titlebarEl.style.width = (win.w - 4) + 'px';

            formContent.style.width = (win.w - 4) + 'px';
            formContent.style.height = (win.h - 20) + 'px';

            selectedControl = null;

            // Recreate controls
            win.controls.forEach(control => {
                createControlElement(control, win);
            });

            // Update grid background for this window
            setGridFromUI();
            updateGridBackground();

            nextId = win.nextControlId;
        }

        function createControlElement(control, win) {
            const el = document.createElement('div');
            el.className = 'control control-' + control.type;
            el.style.left = control.x + 'px';
            el.style.top = control.y + 'px';

            if (control.type === 'button') {
                el.style.width = control.w + 'px';
                el.style.height = control.h + 'px';
                el.textContent = control.text;

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'control-resize-handle br';
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    resizingControl = true;
                    resizeControlStart.x = e.clientX;
                    resizeControlStart.y = e.clientY;
                    resizeControlStart.w = control.w;
                    resizeControlStart.h = control.h;
                    draggedControl = control;
                });
                el.appendChild(resizeHandle);
            } else if (control.type === 'label') {
                const displayText = control.text.replace(/\\n/g, '\n');
                el.textContent = displayText;
                el.style.color = osletColors[control.fg].rgb;
                el.style.backgroundColor = osletColors[control.bg].rgb;
                el.style.fontSize = control.font_size + 'px';
                el.style.lineHeight = '1.2';

                // Use explicit dimensions if set (w > 0)
                if (control.w > 0) {
                    el.style.width = control.w + 'px';
                }
                if (control.h > 0) {
                    el.style.height = control.h + 'px';
                }

                const fontWeights = ['normal', 'bold', 'normal', 'bold'];
                const fontStyles = ['normal', 'normal', 'italic', 'italic'];
                el.style.fontWeight = fontWeights[control.font_type];
                el.style.fontStyle = fontStyles[control.font_type];

                if (control.border) {
                    el.style.border = '1px solid ' + osletColors[control.border_color].rgb;
                }

                // Add resize handle for labels with explicit dimensions
                if (control.w > 0 || control.h > 0) {
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'control-resize-handle br';
                    resizeHandle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        resizingControl = true;
                        resizeControlStart.x = e.clientX;
                        resizeControlStart.y = e.clientY;
                        resizeControlStart.w = control.w;
                        resizeControlStart.h = control.h;
                        draggedControl = control;
                    });
                    el.appendChild(resizeHandle);
                }
            } else if (control.type === 'picturebox') {
                el.style.width = control.w + 'px';
                el.style.height = control.h + 'px';
                el.textContent = '[Image]';

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'control-resize-handle br';
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    resizingControl = true;
                    resizeControlStart.x = e.clientX;
                    resizeControlStart.y = e.clientY;
                    resizeControlStart.w = control.w;
                    resizeControlStart.h = control.h;
                    draggedControl = control;
                });
                el.appendChild(resizeHandle);
            } else if (control.type === 'checkbox') {
                el.style.width = 'auto';
                el.style.height = '13px';
                el.style.lineHeight = '13px';

                const box = document.createElement('div');
                box.style.width = '13px';
                box.style.height = '13px';
                box.style.display = 'inline-block';
                box.style.verticalAlign = 'middle';
                // 3D sunken effect matching osLET
                box.style.borderTop = '1px solid #808080';
                box.style.borderLeft = '1px solid #808080';
                box.style.borderBottom = '1px solid #dfdfdf';
                box.style.borderRight = '1px solid #dfdfdf';
                box.style.backgroundColor = 'white';
                box.style.boxShadow = 'inset 1px 1px 0 #404040';

                if (control.checked) {
                    // Draw X checkmark using SVG (7 pixels diagonal lines)
                    const svg = `<svg width="13" height="13" xmlns="http://www.w3.org/2000/svg">
                        <line x1="3" y1="3" x2="9" y2="9" stroke="black" stroke-width="1"/>
                        <line x1="4" y1="3" x2="10" y2="9" stroke="black" stroke-width="1"/>
                        <line x1="9" y1="3" x2="3" y2="9" stroke="black" stroke-width="1"/>
                        <line x1="10" y1="3" x2="4" y2="9" stroke="black" stroke-width="1"/>
                    </svg>`;
                    box.innerHTML = svg;
                }

                const label = document.createElement('span');
                label.textContent = control.text;
                label.style.marginLeft = '4px';
                label.style.fontSize = '12px';
                label.style.verticalAlign = 'middle';
                label.style.color = 'black';

                el.appendChild(box);
                el.appendChild(label);

                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    control.checked = control.checked ? 0 : 1;
                    // Remove existing element before recreating to avoid duplicates
                    if (control.el) {
                        control.el.remove();
                    }
                    createControlElement(control, getCurrentWindow());
                    selectControl(control);
                    updateProperties();
                });
            } else if (control.type === 'radiobutton') {
                el.style.width = 'auto';
                el.style.height = '12px';
                el.style.lineHeight = '12px';

                const circle = document.createElement('div');
                circle.style.width = '12px';
                circle.style.height = '12px';
                circle.style.display = 'inline-block';
                circle.style.verticalAlign = 'middle';
                circle.style.border = '1px solid #808080';
                circle.style.borderRadius = '50%';
                circle.style.backgroundColor = 'white';

                if (control.checked) {
                    // Draw filled dot matching osLET (radius 2, 1, and center pixel)
                    const svg = `<svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="6" cy="6" r="2" fill="black"/>
                        <circle cx="6" cy="6" r="1" fill="black"/>
                        <rect x="5.5" y="5.5" width="1" height="1" fill="black"/>
                    </svg>`;
                    circle.innerHTML = svg;
                }

                const label = document.createElement('span');
                label.textContent = control.text;
                label.style.marginLeft = '4px';
                label.style.fontSize = '12px';
                label.style.verticalAlign = 'middle';
                label.style.color = 'black';

                el.appendChild(circle);
                el.appendChild(label);

                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const win = getCurrentWindow();
                    // Uncheck other radios in same group
                    win.controls.forEach(c => {
                        if (c.type === 'radiobutton' && c.group_id === control.group_id) {
                            c.checked = 0;
                        }
                    });
                    control.checked = 1;
                    // Redraw all radio buttons
                    win.controls.forEach(c => {
                        if (c.type === 'radiobutton' && c.el) {
                            c.el.remove();
                            createControlElement(c, win);
                        }
                    });
                    selectControl(control);
                    updateProperties();
                });
            } else if (control.type === 'textbox') {
                el.style.width = control.w + 'px';
                el.style.height = control.h + 'px';
                // 3D sunken effect matching osLET
                el.style.borderTop = '1px solid #808080';
                el.style.borderLeft = '1px solid #808080';
                el.style.borderBottom = '1px solid #dfdfdf';
                el.style.borderRight = '1px solid #dfdfdf';
                el.style.backgroundColor = 'white';
                el.style.color = 'black';
                el.style.boxShadow = 'inset 1px 1px 0 #404040';
                el.style.fontSize = '12px';
                el.style.padding = '6px 0 0 4px'; // Match osLET: text at y+6, x+4
                el.style.boxSizing = 'border-box';
                el.style.overflow = 'hidden';
                el.textContent = control.text;

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'control-resize-handle br';
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    resizingControl = true;
                    resizeControlStart.x = e.clientX;
                    resizeControlStart.y = e.clientY;
                    resizeControlStart.w = control.w;
                    resizeControlStart.h = control.h;
                    draggedControl = control;
                });
                el.appendChild(resizeHandle);
            } else if (control.type === 'dropdown') {
                el.style.width = control.w + 'px';
                el.style.height = control.h + 'px';

                const field = document.createElement('div');
                field.className = 'dropdown-field';
                // Show first item (before first |)
                const firstItem = control.text.split('|')[0] || '';
                field.textContent = firstItem;

                const btn = document.createElement('div');
                btn.className = 'dropdown-btn';
                btn.style.position = 'relative';

                const arrow = document.createElement('div');
                arrow.className = 'dropdown-arrow';
                btn.appendChild(arrow);

                el.appendChild(field);
                el.appendChild(btn);

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'control-resize-handle br';
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    resizingControl = true;
                    resizeControlStart.x = e.clientX;
                    resizeControlStart.y = e.clientY;
                    resizeControlStart.w = control.w;
                    resizeControlStart.h = control.h;
                    draggedControl = control;
                });
                el.appendChild(resizeHandle);
            } else if (control.type === 'frame') {
                el.style.width = control.w + 'px';
                el.style.height = control.h + 'px';
                // Note: position is 'absolute' from .control class, but acts as 'relative' for child elements
                el.style.boxSizing = 'border-box';

                // Frame border starts at ~half font height from top (font_height/2 + 2)
                const borderOffset = 8; // For 12px font: 12/2 + 2 = 8

                const titleOffset = 8;
                const textWidth = control.text ? control.text.length * 7 : 0; // Approximate

                // Left side of top border (before title)
                const topLeft = document.createElement('div');
                topLeft.style.position = 'absolute';
                topLeft.style.top = borderOffset + 'px';
                topLeft.style.left = '0';
                topLeft.style.width = titleOffset + 'px';
                topLeft.style.height = '0';
                topLeft.style.borderTop = '1px solid #808080';
                el.appendChild(topLeft);

                // Right side of top border (after title)
                if (control.text) {
                    const topRight = document.createElement('div');
                    topRight.style.position = 'absolute';
                    topRight.style.top = borderOffset + 'px';
                    topRight.style.left = (titleOffset + textWidth + 8) + 'px';
                    topRight.style.right = '0';
                    topRight.style.height = '0';
                    topRight.style.borderTop = '1px solid #808080';
                    el.appendChild(topRight);
                }

                // Left border
                const leftBorder = document.createElement('div');
                leftBorder.style.position = 'absolute';
                leftBorder.style.top = borderOffset + 'px';
                leftBorder.style.left = '0';
                leftBorder.style.bottom = '0';
                leftBorder.style.width = '0';
                leftBorder.style.borderLeft = '1px solid #808080';
                el.appendChild(leftBorder);

                // Bottom border
                const bottomBorder = document.createElement('div');
                bottomBorder.style.position = 'absolute';
                bottomBorder.style.bottom = '0';
                bottomBorder.style.left = '0';
                bottomBorder.style.right = '0';
                bottomBorder.style.height = '0';
                bottomBorder.style.borderBottom = '1px solid #dfdfdf';
                el.appendChild(bottomBorder);

                // Right border
                const rightBorder = document.createElement('div');
                rightBorder.style.position = 'absolute';
                rightBorder.style.top = borderOffset + 'px';
                rightBorder.style.right = '0';
                rightBorder.style.bottom = '0';
                rightBorder.style.width = '0';
                rightBorder.style.borderRight = '1px solid #dfdfdf';
                el.appendChild(rightBorder);

                // Title text - NO background, positioned at top
                const frameTitle = document.createElement('span');
                frameTitle.textContent = control.text;
                frameTitle.style.position = 'absolute';
                frameTitle.style.top = '0px'; // Match osLET: text starts at abs_y, then +5 for baseline
                frameTitle.style.left = '12px'; // title_offset + 4 = 8 + 4 = 12
                frameTitle.style.fontSize = '12px';
                frameTitle.style.lineHeight = '12px';
                frameTitle.style.color = 'black'; // Match osLET fg color
                el.appendChild(frameTitle);

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'control-resize-handle br';
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    resizingControl = true;
                    resizeControlStart.x = e.clientX;
                    resizeControlStart.y = e.clientY;
                    resizeControlStart.w = control.w;
                    resizeControlStart.h = control.h;
                    draggedControl = control;
                });
                el.appendChild(resizeHandle);
            } else if (control.type === 'scrollbar') {
                el.style.width = control.w + 'px';
                el.style.height = control.h + 'px';
                el.style.boxSizing = 'border-box';
                el.style.backgroundColor = '#a0a0a0';

                const vertical = !control.checked;
                const arrow_size = vertical ? control.w : control.h;
                const track_len = vertical ? (control.h - 2 * arrow_size) : (control.w - 2 * arrow_size);

                // Calculate thumb size and position
                const thumb_size = 20;
                const max_val = control.max_length > 0 ? control.max_length : 100;
                const value = control.cursor_pos || 0;
                let thumb_pos = 0;
                if (max_val > 0 && track_len > thumb_size) {
                    thumb_pos = ((track_len - thumb_size) * value) / max_val;
                }

                if (vertical) {
                    // Up arrow button
                    const upBtn = document.createElement('div');
                    upBtn.style.position = 'absolute';
                    upBtn.style.left = '0';
                    upBtn.style.top = '0';
                    upBtn.style.width = control.w + 'px';
                    upBtn.style.height = arrow_size + 'px';
                    upBtn.style.backgroundColor = '#a0a0a0';
                    upBtn.style.border = '1px solid black';
                    upBtn.style.boxSizing = 'border-box';
                    upBtn.style.borderTopColor = 'white';
                    upBtn.style.borderLeftColor = 'white';
                    upBtn.style.borderRightColor = '#555555';
                    upBtn.style.borderBottomColor = '#555555';
                    // Up arrow (pointing up) - SVG matching controls.c
                    const upArrowSvg = `<svg width="${control.w}" height="${arrow_size}" style="position:absolute;left:0;top:0;pointer-events:none;">
                        <line x1="${control.w/2 - 3}" y1="${arrow_size/2}" x2="${control.w/2 + 3}" y2="${arrow_size/2}" stroke="black" stroke-width="1"/>
                        <line x1="${control.w/2 - 2}" y1="${arrow_size/2 - 1}" x2="${control.w/2 + 2}" y2="${arrow_size/2 - 1}" stroke="black" stroke-width="1"/>
                        <line x1="${control.w/2 - 1}" y1="${arrow_size/2 - 2}" x2="${control.w/2 + 1}" y2="${arrow_size/2 - 2}" stroke="black" stroke-width="1"/>
                        <line x1="${control.w/2}" y1="${arrow_size/2 - 3}" x2="${control.w/2}" y2="${arrow_size/2 - 3}" stroke="black" stroke-width="1"/>
                        <rect x="${control.w/2 - 1}" y="${arrow_size/2 + 1}" width="3" height="3" fill="black"/>
                    </svg>`;
                    upBtn.innerHTML = upArrowSvg;
                    el.appendChild(upBtn);

                    // Track with dither pattern
                    const track = document.createElement('div');
                    track.style.position = 'absolute';
                    track.style.left = '0';
                    track.style.top = arrow_size + 'px';
                    track.style.width = control.w + 'px';
                    track.style.height = track_len + 'px';
                    track.style.backgroundImage = 'repeating-conic-gradient(white 0% 25%, #a0a0a0 0% 50%)';
                    track.style.backgroundSize = '2px 2px';
                    el.appendChild(track);

                    // Thumb
                    const thumb = document.createElement('div');
                    thumb.style.position = 'absolute';
                    thumb.style.left = '0';
                    thumb.style.top = (arrow_size + thumb_pos) + 'px';
                    thumb.style.width = control.w + 'px';
                    thumb.style.height = thumb_size + 'px';
                    thumb.style.backgroundColor = '#a0a0a0';
                    thumb.style.border = '1px solid black';
                    thumb.style.boxSizing = 'border-box';
                    thumb.style.borderTopColor = 'white';
                    thumb.style.borderLeftColor = 'white';
                    thumb.style.borderRightColor = '#555555';
                    thumb.style.borderBottomColor = '#555555';
                    el.appendChild(thumb);

                    // Down arrow button
                    const downBtn = document.createElement('div');
                    downBtn.style.position = 'absolute';
                    downBtn.style.left = '0';
                    downBtn.style.bottom = '0';
                    downBtn.style.width = control.w + 'px';
                    downBtn.style.height = arrow_size + 'px';
                    downBtn.style.backgroundColor = '#a0a0a0';
                    downBtn.style.border = '1px solid black';
                    downBtn.style.boxSizing = 'border-box';
                    downBtn.style.borderTopColor = 'white';
                    downBtn.style.borderLeftColor = 'white';
                    downBtn.style.borderRightColor = '#555555';
                    downBtn.style.borderBottomColor = '#555555';
                    // Down arrow (pointing down) - SVG matching controls.c
                    const downArrowSvg = `<svg width="${control.w}" height="${arrow_size}" style="position:absolute;left:0;top:0;pointer-events:none;">
                        <line x1="${control.w/2 - 3}" y1="${arrow_size/2}" x2="${control.w/2 + 3}" y2="${arrow_size/2}" stroke="black" stroke-width="1"/>
                        <line x1="${control.w/2 - 2}" y1="${arrow_size/2 + 1}" x2="${control.w/2 + 2}" y2="${arrow_size/2 + 1}" stroke="black" stroke-width="1"/>
                        <line x1="${control.w/2 - 1}" y1="${arrow_size/2 + 2}" x2="${control.w/2 + 1}" y2="${arrow_size/2 + 2}" stroke="black" stroke-width="1"/>
                        <line x1="${control.w/2}" y1="${arrow_size/2 + 3}" x2="${control.w/2}" y2="${arrow_size/2 + 3}" stroke="black" stroke-width="1"/>
                        <rect x="${control.w/2 - 1}" y="${arrow_size/2 - 3}" width="3" height="3" fill="black"/>
                    </svg>`;
                    downBtn.innerHTML = downArrowSvg;
                    el.appendChild(downBtn);
                } else {
                    // Horizontal scrollbar
                    // Left arrow button
                    const leftBtn = document.createElement('div');
                    leftBtn.style.position = 'absolute';
                    leftBtn.style.left = '0';
                    leftBtn.style.top = '0';
                    leftBtn.style.width = arrow_size + 'px';
                    leftBtn.style.height = control.h + 'px';
                    leftBtn.style.backgroundColor = '#a0a0a0';
                    leftBtn.style.border = '1px solid black';
                    leftBtn.style.boxSizing = 'border-box';
                    leftBtn.style.borderTopColor = 'white';
                    leftBtn.style.borderLeftColor = 'white';
                    leftBtn.style.borderRightColor = '#555555';
                    leftBtn.style.borderBottomColor = '#555555';
                    // Left arrow (pointing left) - SVG matching controls.c
                    const leftArrowSvg = `<svg width="${arrow_size}" height="${control.h}" style="position:absolute;left:0;top:0;pointer-events:none;">
                        <line x1="${arrow_size/2}" y1="${control.h/2 - 3}" x2="${arrow_size/2}" y2="${control.h/2 + 3}" stroke="black" stroke-width="1"/>
                        <line x1="${arrow_size/2 - 1}" y1="${control.h/2 - 2}" x2="${arrow_size/2 - 1}" y2="${control.h/2 + 2}" stroke="black" stroke-width="1"/>
                        <line x1="${arrow_size/2 - 2}" y1="${control.h/2 - 1}" x2="${arrow_size/2 - 2}" y2="${control.h/2 + 1}" stroke="black" stroke-width="1"/>
                        <line x1="${arrow_size/2 - 3}" y1="${control.h/2}" x2="${arrow_size/2 - 3}" y2="${control.h/2}" stroke="black" stroke-width="1"/>
                        <rect x="${arrow_size/2 + 1}" y="${control.h/2 - 1}" width="3" height="3" fill="black"/>
                    </svg>`;
                    leftBtn.innerHTML = leftArrowSvg;
                    el.appendChild(leftBtn);

                    // Track with dither pattern
                    const track = document.createElement('div');
                    track.style.position = 'absolute';
                    track.style.left = arrow_size + 'px';
                    track.style.top = '0';
                    track.style.width = track_len + 'px';
                    track.style.height = control.h + 'px';
                    track.style.backgroundImage = 'repeating-conic-gradient(white 0% 25%, #a0a0a0 0% 50%)';
                    track.style.backgroundSize = '2px 2px';
                    el.appendChild(track);

                    // Thumb
                    const thumb = document.createElement('div');
                    thumb.style.position = 'absolute';
                    thumb.style.left = (arrow_size + thumb_pos) + 'px';
                    thumb.style.top = '0';
                    thumb.style.width = thumb_size + 'px';
                    thumb.style.height = control.h + 'px';
                    thumb.style.backgroundColor = '#a0a0a0';
                    thumb.style.border = '1px solid black';
                    thumb.style.boxSizing = 'border-box';
                    thumb.style.borderTopColor = 'white';
                    thumb.style.borderLeftColor = 'white';
                    thumb.style.borderRightColor = '#555555';
                    thumb.style.borderBottomColor = '#555555';
                    el.appendChild(thumb);

                    // Right arrow button
                    const rightBtn = document.createElement('div');
                    rightBtn.style.position = 'absolute';
                    rightBtn.style.right = '0';
                    rightBtn.style.top = '0';
                    rightBtn.style.width = arrow_size + 'px';
                    rightBtn.style.height = control.h + 'px';
                    rightBtn.style.backgroundColor = '#a0a0a0';
                    rightBtn.style.border = '1px solid black';
                    rightBtn.style.boxSizing = 'border-box';
                    rightBtn.style.borderTopColor = 'white';
                    rightBtn.style.borderLeftColor = 'white';
                    rightBtn.style.borderRightColor = '#555555';
                    rightBtn.style.borderBottomColor = '#555555';
                    // Right arrow (pointing right) - SVG matching controls.c
                    const rightArrowSvg = `<svg width="${arrow_size}" height="${control.h}" style="position:absolute;left:0;top:0;pointer-events:none;">
                        <line x1="${arrow_size/2}" y1="${control.h/2 - 3}" x2="${arrow_size/2}" y2="${control.h/2 + 3}" stroke="black" stroke-width="1"/>
                        <line x1="${arrow_size/2 + 1}" y1="${control.h/2 - 2}" x2="${arrow_size/2 + 1}" y2="${control.h/2 + 2}" stroke="black" stroke-width="1"/>
                        <line x1="${arrow_size/2 + 2}" y1="${control.h/2 - 1}" x2="${arrow_size/2 + 2}" y2="${control.h/2 + 1}" stroke="black" stroke-width="1"/>
                        <line x1="${arrow_size/2 + 3}" y1="${control.h/2}" x2="${arrow_size/2 + 3}" y2="${control.h/2}" stroke="black" stroke-width="1"/>
                        <rect x="${arrow_size/2 - 3}" y="${control.h/2 - 1}" width="3" height="3" fill="black"/>
                    </svg>`;
                    rightBtn.innerHTML = rightArrowSvg;
                    el.appendChild(rightBtn);
                }

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'control-resize-handle br';
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    resizingControl = true;
                    resizeControlStart.x = e.clientX;
                    resizeControlStart.y = e.clientY;
                    resizeControlStart.w = control.w;
                    resizeControlStart.h = control.h;
                    draggedControl = control;
                });
                el.appendChild(resizeHandle);
            }

            el.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('control-resize-handle')) return;
                e.stopPropagation();
                selectControl(control);
                draggedControl = control;
                resizingControl = false;
                dragOffset.x = e.clientX - formContent.getBoundingClientRect().left - control.x;
                dragOffset.y = e.clientY - formContent.getBoundingClientRect().top - control.y;
            });

            control.el = el;
            formContent.appendChild(el);
        }

        function deleteWindow(index) {
            if (!confirm('Delete this window?')) return;

            project.windows.splice(index, 1);

            if (currentWindowIndex === index) {
                if (project.windows.length > 0) {
                    selectWindow(Math.max(0, index - 1));
                } else {
                    currentWindowIndex = -1;
                    hideCanvas();
                }
            } else if (currentWindowIndex > index) {
                currentWindowIndex--;
            }

            updateWindowsList();
        }

        function updateWindowsList() {
            const list = document.getElementById('windows-list');
            list.innerHTML = '';

            project.windows.forEach((win, index) => {
                const item = document.createElement('div');
                item.className = 'window-item' + (index === currentWindowIndex ? ' active' : '');

                item.innerHTML = `
                    <div class="window-item-header">
                        <div class="window-item-title">${win.name}</div>
                        <button class="window-delete" onclick="event.stopPropagation(); deleteWindow(${index})"></button>
                    </div>
                    <div class="window-item-info">${win.w}${win.h}, ${win.controls.length} controls</div>
                `;

                item.onclick = () => selectWindow(index);
                list.appendChild(item);
            });
        }

        function showCanvas() {
            screenBounds.style.display = 'block';
            noWindowMessage.style.display = 'none';
        }

        function hideCanvas() {
            screenBounds.style.display = 'none';
            noWindowMessage.style.display = 'flex';
            updateProperties();
        }

        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        }

        formContent.addEventListener('click', (e) => {
            if (e.target === formContent) {
                if (currentTool === 'select') {
                    const win = getCurrentWindow();
                    if (win) {
                        win.controls.forEach(c => c.el.classList.remove('selected'));
                    }
                    selectedControl = null;
                    updateProperties();
                } else {
                    addControl(e);
                }
            }
        });

        document.getElementById('titlebar').addEventListener('mousedown', (e) => {
            formDragging = true;
            const screenRect = screenBounds.getBoundingClientRect();
            const currentLeft = parseInt(form.style.left) || 0;
            const currentTop = parseInt(form.style.top) || 0;
            formDragOffset.x = e.clientX - screenRect.left - currentLeft;
            formDragOffset.y = e.clientY - screenRect.top - currentTop;
            e.preventDefault();
        });

        document.querySelectorAll('.resize-handle').forEach(handle => {
            handle.addEventListener('mousedown', (e) => {
                const win = getCurrentWindow();
                if (!win) return;

                resizing = true;
                resizeStart.x = e.clientX;
                resizeStart.y = e.clientY;
                resizeStart.w = win.w;
                resizeStart.h = win.h;

                if (handle.classList.contains('right')) resizeType = 'right';
                else if (handle.classList.contains('bottom')) resizeType = 'bottom';
                else if (handle.classList.contains('br')) resizeType = 'corner';

                e.stopPropagation();
                e.preventDefault();
            });
        });

        document.addEventListener('mousemove', (e) => {
            const win = getCurrentWindow();
            if (!win) return;

            if (formDragging) {
                const screenRect = screenBounds.getBoundingClientRect();

                let newLeft = e.clientX - screenRect.left - formDragOffset.x;
                let newTop = e.clientY - screenRect.top - formDragOffset.y;

                newLeft = Math.max(0, Math.min(newLeft, 640 - win.w));
                newTop = Math.max(0, Math.min(newTop, 480 - win.h));

                if (project.grid && project.grid.snap) {
                    const sz = Math.max(2, project.grid.size || 8);
                    newLeft = Math.round(newLeft / sz) * sz;
                    newTop = Math.round(newTop / sz) * sz;
                }

                form.style.left = newLeft + 'px';
                form.style.top = newTop + 'px';

                win.x = newLeft;
                win.y = newTop;
            }

            if (resizing) {
                const dx = e.clientX - resizeStart.x;
                const dy = e.clientY - resizeStart.y;

                const currentLeft = parseInt(form.style.left) || 0;
                const currentTop = parseInt(form.style.top) || 0;

                if (resizeType === 'right' || resizeType === 'corner') {
                    const maxWidth = 640 - currentLeft;
                    win.w = Math.max(100, Math.min(maxWidth, resizeStart.w + dx));
                }
                if (resizeType === 'bottom' || resizeType === 'corner') {
                    const maxHeight = 480 - currentTop;
                    win.h = Math.max(80, Math.min(maxHeight, resizeStart.h + dy));
                }

                if (project.grid && project.grid.snap) {
                    const sz = Math.max(2, project.grid.size || 8);
                    win.w = Math.max(100, Math.round(win.w / sz) * sz);
                    win.h = Math.max(80, Math.round(win.h / sz) * sz);
                }

                updateFormSize();
                updateWindowsList();
            }

            if (resizing) {
                const dx = e.clientX - resizeStart.x;
                const dy = e.clientY - resizeStart.y;

                const currentLeft = parseInt(form.style.left) || 0;
                const currentTop = parseInt(form.style.top) || 0;

                if (resizeType === 'right' || resizeType === 'corner') {
                    const maxWidth = 640 - currentLeft;
                    win.w = Math.max(100, Math.min(maxWidth, resizeStart.w + dx));
                }
                if (resizeType === 'bottom' || resizeType === 'corner') {
                    const maxHeight = 480 - currentTop;
                    win.h = Math.max(80, Math.min(maxHeight, resizeStart.h + dy));
                }

                updateFormSize();
                updateWindowsList();
            }

            if (resizingControl && draggedControl) {
                const dx = e.clientX - resizeControlStart.x;
                const dy = e.clientY - resizeControlStart.y;

                let newW = Math.max(20, resizeControlStart.w + dx);
                let newH = Math.max(10, resizeControlStart.h + dy);

                if (project.grid && project.grid.snap) {
                    const sz = Math.max(2, project.grid.size || 8);
                    newW = Math.max(sz, Math.round(newW / sz) * sz);
                    newH = Math.max(sz, Math.round(newH / sz) * sz);
                }

                draggedControl.w = newW;
                draggedControl.h = newH;

                draggedControl.el.style.width = draggedControl.w + 'px';
                draggedControl.el.style.height = draggedControl.h + 'px';

                updateProperties();
            }
            else if (draggedControl && !resizingControl) {
                const rect = formContent.getBoundingClientRect();
                let x = e.clientX - rect.left - dragOffset.x;
                let y = e.clientY - rect.top - dragOffset.y;

                x = Math.max(0, x);
                y = Math.max(0, y);

                if (project.grid && project.grid.snap) {
                    const sz = Math.max(2, project.grid.size || 8);
                    x = Math.round(x / sz) * sz;
                    y = Math.round(y / sz) * sz;
                }

                draggedControl.el.style.left = x + 'px';
                draggedControl.el.style.top = y + 'px';
                draggedControl.x = Math.round(x);
                draggedControl.y = Math.round(y);

                updateProperties();
            }
        });

        let isDraggingControl = false;
        let isResizingControlActive = false;

        document.addEventListener('mousedown', (e) => {
            if (draggedControl && !resizingControl) {
                isDraggingControl = true;
            }
            if (resizingControl) {
                isResizingControlActive = true;
            }
        });

        document.addEventListener('mouseup', () => {
            // Save undo state after drag/resize ends
            if ((isDraggingControl || isResizingControlActive) && draggedControl) {
                saveUndoState();
            }

            formDragging = false;
            resizing = false;
            resizingControl = false;
            draggedControl = null;
            isDraggingControl = false;
            isResizingControlActive = false;

            if (resizing) {
                updateWindowsList();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                selectTool('select');
                document.querySelector('.tool-btn:last-of-type').classList.add('active');
            }
            if (e.key === 'Delete' && selectedControl) {
                deleteSelected();
            }
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });

        // Grid UI bindings
        (function bindGridUI(){
            const gridInputEl = document.getElementById('grid-size-input');
            const snapCheckbox = document.getElementById('snap-checkbox');
            const showGridCheckbox = document.getElementById('show-grid-checkbox');

            if (gridInputEl) {
                gridInputEl.addEventListener('input', (e) => {
                    project.grid.size = Math.max(2, parseInt(e.target.value) || 8);
                    setGridFromUI();
                });
            }
            if (snapCheckbox) {
                snapCheckbox.addEventListener('change', (e) => {
                    project.grid.snap = e.target.checked;
                    setGridFromUI();
                });
            }
            if (showGridCheckbox) {
                showGridCheckbox.addEventListener('change', (e) => {
                    project.grid.show = e.target.checked;
                    setGridFromUI();
                });
            }

            // Initialize UI values
            if (gridInputEl) gridInputEl.value = (project.grid && project.grid.size) ? project.grid.size : gridSize;
            if (snapCheckbox) snapCheckbox.checked = !!(project.grid && project.grid.snap);
            if (showGridCheckbox) showGridCheckbox.checked = !!(project.grid && project.grid.show);

            setGridFromUI();
            updateGridBackground();
        })();

        function updateFormSize() {
            const win = getCurrentWindow();
            if (!win) return;

            form.style.width = win.w + 'px';
            form.style.height = win.h + 'px';

            const titlebarEl = document.getElementById('titlebar');
            titlebarEl.style.width = (win.w - 4) + 'px';

            formContent.style.width = (win.w - 4) + 'px';
            formContent.style.height = (win.h - 20) + 'px';
        }

        function addControl(e) {
            const win = getCurrentWindow();
            if (!win) return;

            saveUndoState();

            const rect = formContent.getBoundingClientRect();
            const rawX = Math.round(e.clientX - rect.left);
            const rawY = Math.round(e.clientY - rect.top);
            let x = rawX;
            let y = rawY;
            // Apply snapping on creation if enabled
            if (project.grid && project.grid.snap) {
                const sz = Math.max(2, project.grid.size || 8);
                x = Math.round(x / sz) * sz;
                y = Math.round(y / sz) * sz;
            }

            // Set default dimensions based on control type
            let w = 0, h = 0, text = '', bg = 7;
            switch (currentTool) {
                case 'button':
                    w = 65; h = 23; text = 'Button';
                    break;
                case 'picturebox':
                    w = 100; h = 100; text = 'IMAGE.BMP';
                    break;
                case 'checkbox':
                    w = 13; h = 13; text = 'CheckBox';
                    break;
                case 'radiobutton':
                    w = 12; h = 12; text = 'Radio';
                    break;
                case 'textbox':
                    w = 120; h = 20; text = '';
                    break;
                case 'frame':
                    w = 150; h = 100; text = 'Frame';
                    break;
                case 'dropdown':
                    w = 120; h = 20; text = 'Option 1|Option 2|Option 3';
                    break;
                case 'scrollbar':
                    w = 20; h = 100; text = '';
                    break;
                case 'label':
                    w = 0; h = 0; text = 'Label'; bg = 15;
                    break;
            }

            const control = {
                type: currentTool,
                x: x,
                y: y,
                w: w,
                h: h,
                fg: 0,
                bg: bg,
                text: text,
                id: win.nextControlId++,
                font_type: 0,
                font_size: 12,
                border: 0,
                border_color: 0,
                checked: 0,  // For checkbox, radio, and scrollbar orientation (0=vert, 1=horiz)
                group_id: 0,  // For radio button grouping
                max_length: currentTool === 'textbox' ? 255 : (currentTool === 'scrollbar' ? 100 : 0),  // For textbox or scrollbar max_value
                cursor_pos: 0,  // For scrollbar value
                action: currentTool === 'button' ? { type: 'none', target: '' } : undefined
            };

            win.controls.push(control);
            createControlElement(control, win);
            selectControl(control);
            updateWindowsList();
        }

        function selectControl(control) {
            const win = getCurrentWindow();
            if (!win) return;

            win.controls.forEach(c => {
                if (c.el) c.el.classList.remove('selected');
            });
            if (control.el) {
                control.el.classList.add('selected');
            }
            selectedControl = control;
            updateProperties();
        }

        function updateProperties() {
            const win = getCurrentWindow();

            if (!win) {
                document.getElementById('prop-content').innerHTML = '<p style="color: #666; font-size: 12px;">No window selected</p>';
                return;
            }

            if (!selectedControl) {
                // Show window properties
                let html = `
                    <div class="prop-group">
                        <div class="prop-label">Window Name</div>
                        <input class="prop-input" value="${win.name}" onchange="updateWindowName(this.value)">
                    </div>
                    <div class="prop-group">
                        <div class="prop-label">Window Title</div>
                        <input class="prop-input" value="${win.title}" onchange="updateWindowTitle(this.value)">
                    </div>
                    <div class="prop-group">
                        <div class="prop-label">Icon Path</div>
                        <input class="prop-input" value="${win.icon || ''}" placeholder="e.g. C:/ICONS/APP.ICO" onchange="updateWindowIcon(this.value)">
                    </div>
                    <div class="prop-group">
                        <div class="prop-label">Width</div>
                        <input class="prop-input" type="number" value="${win.w}" onchange="updateWindowDimension('w', parseInt(this.value))">
                    </div>
                    <div class="prop-group">
                        <div class="prop-label">Height</div>
                        <input class="prop-input" type="number" value="${win.h}" onchange="updateWindowDimension('h', parseInt(this.value))">
                    </div>
                `;
                document.getElementById('prop-content').innerHTML = html;
                return;
            }

            // Show control properties with action editor for buttons
            if (selectedControl.type === 'button') {
                showButtonProperties(selectedControl);
                return;
            }

            const c = selectedControl;
            const typeMap = {
                'button': 'CTRL_BUTTON',
                'label': 'CTRL_LABEL',
                'picturebox': 'CTRL_PICTUREBOX',
                'checkbox': 'CTRL_CHECKBOX',
                'radiobutton': 'CTRL_RADIOBUTTON',
                'textbox': 'CTRL_TEXTBOX',
                'frame': 'CTRL_FRAME',
                'dropdown': 'CTRL_DROPDOWN',
                'scrollbar': 'CTRL_SCROLLBAR'
            };
            const typeLabel = typeMap[c.type] || 'UNKNOWN';

            let html = `
                <div class="prop-group">
                    <div class="prop-label">Type</div>
                    <input class="prop-input" value="${typeLabel}" disabled>
                </div>
                <div class="prop-group">
                    <div class="prop-label">ID</div>
                    <input class="prop-input" type="number" value="${c.id}" onchange="selectedControl.id = parseInt(this.value)">
                </div>
                <div class="prop-group">
                    <div class="prop-label">X</div>
                    <input class="prop-input" type="number" value="${c.x}" onchange="updatePosition('x', parseInt(this.value))">
                </div>
                <div class="prop-group">
                    <div class="prop-label">Y</div>
                    <input class="prop-input" type="number" value="${c.y}" onchange="updatePosition('y', parseInt(this.value))">
                </div>
            `;

            // Show width/height for all control types
            // Labels use 0 for auto-size, but can have explicit dimensions
            html += `
                <div class="prop-group">
                    <div class="prop-label">Width${c.type === 'label' ? ' (0=auto)' : ''}</div>
                    <input class="prop-input" type="number" value="${c.w}" onchange="updateSize('w', parseInt(this.value))">
                </div>
                <div class="prop-group">
                    <div class="prop-label">Height${c.type === 'label' ? ' (0=auto)' : ''}</div>
                    <input class="prop-input" type="number" value="${c.h}" onchange="updateSize('h', parseInt(this.value))">
                </div>
            `;

            if (c.type === 'label') {
                const editText = c.text.replace(/\\n/g, '\n');
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Text (use Enter for new lines)</div>
                        <textarea class="prop-input" rows="3" onchange="updateText(this.value)">${editText}</textarea>
                    </div>
                `;
            } else {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Text</div>
                        <input class="prop-input" value="${c.text}" onchange="updateText(this.value)">
                    </div>
                `;
            }

            if (c.type === 'label') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Font Type</div>
                        <select class="prop-input" onchange="updateFontType(parseInt(this.value))">
                            <option value="0" ${c.font_type === 0 ? 'selected' : ''}>Normal</option>
                            <option value="1" ${c.font_type === 1 ? 'selected' : ''}>Bold</option>
                            <option value="2" ${c.font_type === 2 ? 'selected' : ''}>Italic</option>
                            <option value="3" ${c.font_type === 3 ? 'selected' : ''}>Bold Italic</option>
                        </select>
                    </div>
                    <div class="prop-group">
                        <div class="prop-label">Font Size</div>
                        <input class="prop-input" type="number" value="${c.font_size}" onchange="updateFontSize(parseInt(this.value))">
                    </div>
                `;
                html += `<div class="prop-group">
                    <div class="prop-label">Foreground Color</div>
                    <div class="color-grid">`;
                osletColors.forEach(col => {
                    html += `<div class="color-btn ${c.fg === col.val ? 'selected' : ''}" style="background: ${col.rgb}"
                             onclick="updateColor('fg', ${col.val})" title="${col.name}"></div>`;
                });
                html += `</div></div>`;
            }

            if (c.type === 'label') {
                html += `<div class="prop-group">
                    <div class="prop-label">Background Color</div>
                    <div class="color-grid">`;
                osletColors.forEach(col => {
                    html += `<div class="color-btn ${c.bg === col.val ? 'selected' : ''}" style="background: ${col.rgb}"
                             onclick="updateColor('bg', ${col.val})" title="${col.name}"></div>`;
                });
                html += `</div></div>`;

                html += `
                    <div class="prop-group">
                        <div class="prop-label">Border</div>
                        <select class="prop-input" onchange="updateBorder(parseInt(this.value))">
                            <option value="0" ${c.border === 0 ? 'selected' : ''}>None</option>
                            <option value="1" ${c.border === 1 ? 'selected' : ''}>Enabled</option>
                        </select>
                    </div>
                `;

                if (c.border) {
                    html += `<div class="prop-group">
                        <div class="prop-label">Border Color</div>
                        <div class="color-grid">`;
                    osletColors.forEach(col => {
                        html += `<div class="color-btn ${c.border_color === col.val ? 'selected' : ''}" style="background: ${col.rgb}"
                                 onclick="updateBorderColor(${col.val})" title="${col.name}"></div>`;
                    });
                    html += `</div></div>`;
                }
            }

            if (c.type === 'button') {
                html += `<div class="prop-group">
                    <div class="prop-label">Background Color</div>
                    <div class="color-grid">`;
                osletColors.forEach(col => {
                    html += `<div class="color-btn ${c.bg === col.val ? 'selected' : ''}" style="background: ${col.rgb}"
                             onclick="updateColor('bg', ${col.val})" title="${col.name}"></div>`;
                });
                html += `</div></div>`;
            }

            // Add checked property for checkbox and radio button
            if (c.type === 'checkbox' || c.type === 'radiobutton') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Checked</div>
                        <select class="prop-input" onchange="updateChecked(parseInt(this.value))">
                            <option value="0" ${c.checked === 0 ? 'selected' : ''}>Unchecked</option>
                            <option value="1" ${c.checked === 1 ? 'selected' : ''}>Checked</option>
                        </select>
                    </div>
                `;
            }

            // Add group_id property for radio button
            if (c.type === 'radiobutton') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Group ID</div>
                        <input class="prop-input" type="number" value="${c.group_id || 0}" onchange="updateGroupId(parseInt(this.value))">
                    </div>
                `;
            }

            // Add max_length property for textbox
            if (c.type === 'textbox') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Max Length</div>
                        <input class="prop-input" type="number" value="${c.max_length || 255}" onchange="updateMaxLength(parseInt(this.value))">
                    </div>
                `;
            }

            // Add options property for dropdown (pipe-separated)
            if (c.type === 'dropdown') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Options (separated by |)</div>
                        <textarea class="prop-input" rows="4" onchange="updateText(this.value)">${c.text}</textarea>
                    </div>
                    <div class="prop-group">
                        <div class="prop-label">Items: ${c.text.split('|').length}</div>
                    </div>
                `;
            }

            // Add scrollbar-specific properties
            if (c.type === 'scrollbar') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Orientation</div>
                        <select class="prop-input" onchange="updateScrollbarOrientation(parseInt(this.value))">
                            <option value="0" ${c.checked === 0 ? 'selected' : ''}>Vertical</option>
                            <option value="1" ${c.checked === 1 ? 'selected' : ''}>Horizontal</option>
                        </select>
                    </div>
                    <div class="prop-group">
                        <div class="prop-label">Value (cursor_pos)</div>
                        <input class="prop-input" type="number" value="${c.cursor_pos || 0}" min="0" onchange="updateScrollbarValue(parseInt(this.value))">
                    </div>
                    <div class="prop-group">
                        <div class="prop-label">Max Value (max_length)</div>
                        <input class="prop-input" type="number" value="${c.max_length || 100}" min="1" onchange="updateScrollbarMaxValue(parseInt(this.value))">
                    </div>
                `;
            }

            document.getElementById('prop-content').innerHTML = html;
        }

        function updateWindowName(value) {
            const win = getCurrentWindow();
            if (win) {
                win.name = value;
                updateWindowsList();
            }
        }

        function updateWindowTitle(value) {
            const win = getCurrentWindow();
            if (win) {
                win.title = value;
                formTitle.textContent = value;
            }
        }

        function updateWindowIcon(value) {
            const win = getCurrentWindow();
            if (win) {
                win.icon = value;
            }
        }

        function updateWindowDimension(axis, value) {
            const win = getCurrentWindow();
            if (!win) return;

            if (axis === 'w') {
                win.w = Math.max(100, value);
            } else {
                win.h = Math.max(80, value);
            }
            updateFormSize();
            updateProperties();
            updateWindowsList();
        }

        function updatePosition(axis, value) {
            selectedControl[axis] = value;
            selectedControl.el.style[axis === 'x' ? 'left' : 'top'] = value + 'px';
        }

        function updateSize(axis, value) {
            selectedControl[axis] = value;
            const styleProp = axis === 'w' ? 'width' : 'height';
            // For labels, 0 means auto-size
            if (selectedControl.type === 'label' && value === 0) {
                selectedControl.el.style[styleProp] = '';  // Remove explicit size
            } else {
                selectedControl.el.style[styleProp] = value + 'px';
            }
        }

        function updateText(value) {
            selectedControl.text = value.replace(/\n/g, '\\n');

            // For frames and dropdowns, we need to recreate the entire element because of complex structure
            if (selectedControl.type === 'frame' || selectedControl.type === 'dropdown') {
                const win = getCurrentWindow();
                if (win && selectedControl.el) {
                    selectedControl.el.remove();
                    createControlElement(selectedControl, win);
                    selectControl(selectedControl);
                }
            } else {
                selectedControl.el.textContent = value;
            }
        }

        function updateFontType(value) {
            selectedControl.font_type = value;
            const fontWeights = ['normal', 'bold', 'normal', 'bold'];
            const fontStyles = ['normal', 'normal', 'italic', 'italic'];
            selectedControl.el.style.fontWeight = fontWeights[value];
            selectedControl.el.style.fontStyle = fontStyles[value];
        }

        function updateFontSize(value) {
            selectedControl.font_size = Math.max(6, Math.min(32, value));
            selectedControl.el.style.fontSize = selectedControl.font_size + 'px';
            selectedControl.el.style.lineHeight = '1.2';
            updateProperties();
        }

        function updateBorder(value) {
            selectedControl.border = value;
            if (value) {
                selectedControl.el.style.border = '1px solid ' + osletColors[selectedControl.border_color].rgb;
            } else {
                selectedControl.el.style.border = 'none';
            }
            updateProperties();
        }

        function updateBorderColor(value) {
            selectedControl.border_color = value;
            if (selectedControl.border) {
                selectedControl.el.style.border = '1px solid ' + osletColors[value].rgb;
            }
            updateProperties();
        }

        function updateColor(type, value) {
            selectedControl[type] = value;
            if (type === 'fg' && selectedControl.type === 'label') {
                selectedControl.el.style.color = osletColors[value].rgb;
            } else if (type === 'bg') {
                if (selectedControl.type === 'button') {
                    selectedControl.el.style.background = osletColors[value].rgb;
                } else if (selectedControl.type === 'label') {
                    selectedControl.el.style.backgroundColor = osletColors[value].rgb;
                }
            }
            updateProperties();
        }

        function updateChecked(value) {
            if (!selectedControl) return;
            const win = getCurrentWindow();
            if (!win) return;

            selectedControl.checked = value;

            // Redraw the control
            if (selectedControl.el) {
                selectedControl.el.remove();
                createControlElement(selectedControl, win);
            }

            // If radio button, uncheck others in same group
            if (selectedControl.type === 'radiobutton' && value === 1) {
                win.controls.forEach(c => {
                    if (c.type === 'radiobutton' && c.group_id === selectedControl.group_id && c !== selectedControl) {
                        c.checked = 0;
                        if (c.el) {
                            c.el.remove();
                            createControlElement(c, win);
                        }
                    }
                });
            }

            selectControl(selectedControl);
        }

        function updateGroupId(value) {
            if (!selectedControl) return;
            selectedControl.group_id = value;
            updateProperties();
        }

        function updateMaxLength(value) {
            if (!selectedControl) return;
            selectedControl.max_length = Math.max(1, Math.min(255, value));
            updateProperties();
        }

        function updateScrollbarOrientation(value) {
            if (!selectedControl) return;
            const oldOrientation = selectedControl.checked;
            selectedControl.checked = value; // 0=vertical, 1=horizontal
            
            // Swap width and height when changing orientation for better usability
            if (oldOrientation !== value) {
                const temp = selectedControl.w;
                selectedControl.w = selectedControl.h;
                selectedControl.h = temp;
            }
            
            // Recreate the control element to update the visual representation
            if (selectedControl.el) {
                const win = getCurrentWindow();
                selectedControl.el.remove();
                createControlElement(selectedControl, win);
                selectControl(selectedControl);
            }
            updateProperties();
        }

        function updateScrollbarValue(value) {
            if (!selectedControl) return;
            const maxVal = selectedControl.max_length || 100;
            selectedControl.cursor_pos = Math.max(0, Math.min(maxVal, value));
            // Recreate the control element to update the visual representation
            if (selectedControl.el) {
                const win = getCurrentWindow();
                selectedControl.el.remove();
                createControlElement(selectedControl, win);
                selectControl(selectedControl);
            }
            updateProperties();
        }

        function updateScrollbarMaxValue(value) {
            if (!selectedControl) return;
            selectedControl.max_length = Math.max(1, value);
            // Ensure cursor_pos doesn't exceed max_length
            if (selectedControl.cursor_pos > selectedControl.max_length) {
                selectedControl.cursor_pos = selectedControl.max_length;
            }
            // Recreate the control element to update the visual representation
            if (selectedControl.el) {
                const win = getCurrentWindow();
                selectedControl.el.remove();
                createControlElement(selectedControl, win);
                selectControl(selectedControl);
            }
            updateProperties();
        }

        function showButtonProperties(control) {
            const win = getCurrentWindow();
            const c = control;

            let html = `
                <div class="prop-group">
                    <div class="prop-label">Type</div>
                    <input class="prop-input" value="CTRL_BUTTON" disabled>
                </div>
                <div class="prop-group">
                    <div class="prop-label">ID</div>
                    <input class="prop-input" type="number" value="${c.id}" onchange="selectedControl.id = parseInt(this.value)">
                </div>
                <div class="prop-group">
                    <div class="prop-label">Text</div>
                    <input class="prop-input" value="${c.text}" onchange="updateText(this.value)">
                </div>
                <div class="prop-group">
                    <div class="prop-label">X</div>
                    <input class="prop-input" type="number" value="${c.x}" onchange="updatePosition('x', parseInt(this.value))">
                </div>
                <div class="prop-group">
                    <div class="prop-label">Y</div>
                    <input class="prop-input" type="number" value="${c.y}" onchange="updatePosition('y', parseInt(this.value))">
                </div>
                <div class="prop-group">
                    <div class="prop-label">Width</div>
                    <input class="prop-input" type="number" value="${c.w}" onchange="updateSize('w', parseInt(this.value))">
                </div>
                <div class="prop-group">
                    <div class="prop-label">Height</div>
                    <input class="prop-input" type="number" value="${c.h}" onchange="updateSize('h', parseInt(this.value))">
                </div>
                <div class="prop-group">
                    <div class="prop-label">Background Color</div>
                    <div class="color-grid">`;
            osletColors.forEach(col => {
                html += `<div class="color-btn ${c.bg === col.val ? 'selected' : ''}" style="background: ${col.rgb}"
                         onclick="updateColor('bg', ${col.val})" title="${col.name}"></div>`;
            });
            html += `</div></div>`;

            // Button action configuration
            html += `
                <h3 style="margin-top: 20px;">Button Action</h3>
                <div class="prop-group">
                    <div class="prop-label">Action Type</div>
                    <select class="prop-input" onchange="updateButtonAction('type', this.value)">
                        <option value="none" ${!c.action || c.action.type === 'none' ? 'selected' : ''}>None (TODO)</option>
                        <option value="show_form" ${c.action && c.action.type === 'show_form' ? 'selected' : ''}>Show Form</option>
                        <option value="hide_form" ${c.action && c.action.type === 'hide_form' ? 'selected' : ''}>Hide Form</option>
                        <option value="exit" ${c.action && c.action.type === 'exit' ? 'selected' : ''}>Exit Application</option>
                        <optgroup label=" Control Properties ">
                            <option value="copy_text" ${c.action && c.action.type === 'copy_text' ? 'selected' : ''}>Copy Text (Label.Text = TextBox.Text)</option>
                            <option value="set_text" ${c.action && c.action.type === 'set_text' ? 'selected' : ''}>Set Text (Label.Text = "...")</option>
                            <option value="set_image" ${c.action && c.action.type === 'set_image' ? 'selected' : ''}>Set Image (from TextBox path)</option>
                            <option value="toggle_checked" ${c.action && c.action.type === 'toggle_checked' ? 'selected' : ''}>Toggle Checked</option>
                            <option value="set_visible" ${c.action && c.action.type === 'set_visible' ? 'selected' : ''}>Show/Hide Control</option>
                            <option value="set_color" ${c.action && c.action.type === 'set_color' ? 'selected' : ''}>Change Color</option>
                        </optgroup>
                        <optgroup label=" Advanced ">
                            <option value="custom" ${c.action && c.action.type === 'custom' ? 'selected' : ''}>Custom Code (C)</option>
                        </optgroup>
                    </select>
                </div>
            `;

            // Form-based actions (show/hide form)
            if (c.action && (c.action.type === 'show_form' || c.action.type === 'hide_form')) {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Target Form</div>
                        <select class="prop-input" onchange="updateButtonAction('target', this.value)">
                            <option value="">-- Select Form --</option>`;
                project.windows.forEach(w => {
                    if (w.name !== win.name) {
                        const selected = c.action.target === w.name ? 'selected' : '';
                        html += `<option value="${w.name}" ${selected}>${w.name}</option>`;
                    }
                });
                html += `</select></div>`;
            }

            // Copy text: source control -> target control
            if (c.action && c.action.type === 'copy_text') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Source Control</div>
                        <select class="prop-input" onchange="updateButtonAction('source_id', parseInt(this.value))">
                            <option value="">-- Select Source --</option>`;
                win.controls.filter(ctrl => ['textbox', 'label'].includes(ctrl.type) && ctrl.id !== c.id).forEach(ctrl => {
                    const selected = c.action.source_id === ctrl.id ? 'selected' : '';
                    html += `<option value="${ctrl.id}" ${selected}>${ctrl.type}#${ctrl.id}: "${ctrl.text.substring(0, 15)}"</option>`;
                });
                html += `</select></div>
                    <div class="prop-group">
                        <div class="prop-label">Target Control</div>
                        <select class="prop-input" onchange="updateButtonAction('target_id', parseInt(this.value))">
                            <option value="">-- Select Target --</option>`;
                win.controls.filter(ctrl => ['textbox', 'label', 'picturebox'].includes(ctrl.type) && ctrl.id !== c.id).forEach(ctrl => {
                    const selected = c.action.target_id === ctrl.id ? 'selected' : '';
                    html += `<option value="${ctrl.id}" ${selected}>${ctrl.type}#${ctrl.id}: "${ctrl.text.substring(0, 15)}"</option>`;
                });
                html += `</select></div>`;
            }

            // Set text: literal value -> target control
            if (c.action && c.action.type === 'set_text') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Target Control</div>
                        <select class="prop-input" onchange="updateButtonAction('target_id', parseInt(this.value))">
                            <option value="">-- Select Target --</option>`;
                win.controls.filter(ctrl => ['textbox', 'label'].includes(ctrl.type) && ctrl.id !== c.id).forEach(ctrl => {
                    const selected = c.action.target_id === ctrl.id ? 'selected' : '';
                    html += `<option value="${ctrl.id}" ${selected}>${ctrl.type}#${ctrl.id}</option>`;
                });
                html += `</select></div>
                    <div class="prop-group">
                        <div class="prop-label">Text Value</div>
                        <input type="text" class="prop-input" value="${c.action.value || ''}"
                               onchange="updateButtonAction('value', this.value)">
                    </div>`;
            }

            // Set image: textbox path -> picturebox
            if (c.action && c.action.type === 'set_image') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Path Source (TextBox)</div>
                        <select class="prop-input" onchange="updateButtonAction('source_id', parseInt(this.value))">
                            <option value="">-- Select TextBox --</option>`;
                win.controls.filter(ctrl => ctrl.type === 'textbox').forEach(ctrl => {
                    const selected = c.action.source_id === ctrl.id ? 'selected' : '';
                    html += `<option value="${ctrl.id}" ${selected}>textbox#${ctrl.id}</option>`;
                });
                html += `</select></div>
                    <div class="prop-group">
                        <div class="prop-label">Target PictureBox</div>
                        <select class="prop-input" onchange="updateButtonAction('target_id', parseInt(this.value))">
                            <option value="">-- Select PictureBox --</option>`;
                win.controls.filter(ctrl => ctrl.type === 'picturebox').forEach(ctrl => {
                    const selected = c.action.target_id === ctrl.id ? 'selected' : '';
                    html += `<option value="${ctrl.id}" ${selected}>picturebox#${ctrl.id}</option>`;
                });
                html += `</select></div>`;
            }

            // Toggle checked: for checkbox/radiobutton
            if (c.action && c.action.type === 'toggle_checked') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Target Control</div>
                        <select class="prop-input" onchange="updateButtonAction('target_id', parseInt(this.value))">
                            <option value="">-- Select Control --</option>`;
                win.controls.filter(ctrl => ['checkbox', 'radiobutton'].includes(ctrl.type)).forEach(ctrl => {
                    const selected = c.action.target_id === ctrl.id ? 'selected' : '';
                    html += `<option value="${ctrl.id}" ${selected}>${ctrl.type}#${ctrl.id}: "${ctrl.text}"</option>`;
                });
                html += `</select></div>`;
            }

            // Show/hide control
            if (c.action && c.action.type === 'set_visible') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Target Control</div>
                        <select class="prop-input" onchange="updateButtonAction('target_id', parseInt(this.value))">
                            <option value="">-- Select Control --</option>`;
                win.controls.filter(ctrl => ctrl.id !== c.id).forEach(ctrl => {
                    const selected = c.action.target_id === ctrl.id ? 'selected' : '';
                    html += `<option value="${ctrl.id}" ${selected}>${ctrl.type}#${ctrl.id}</option>`;
                });
                html += `</select></div>
                    <div class="prop-group">
                        <div class="prop-label">Visibility</div>
                        <select class="prop-input" onchange="updateButtonAction('value', parseInt(this.value))">
                            <option value="1" ${c.action.value === 1 ? 'selected' : ''}>Show</option>
                            <option value="0" ${c.action.value === 0 ? 'selected' : ''}>Hide</option>
                        </select>
                    </div>`;
            }

            // Change color
            if (c.action && c.action.type === 'set_color') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Target Control</div>
                        <select class="prop-input" onchange="updateButtonAction('target_id', parseInt(this.value))">
                            <option value="">-- Select Control --</option>`;
                win.controls.filter(ctrl => ctrl.id !== c.id).forEach(ctrl => {
                    const selected = c.action.target_id === ctrl.id ? 'selected' : '';
                    html += `<option value="${ctrl.id}" ${selected}>${ctrl.type}#${ctrl.id}</option>`;
                });
                html += `</select></div>
                    <div class="prop-group">
                        <div class="prop-label">Property</div>
                        <select class="prop-input" onchange="updateButtonAction('prop', this.value)">
                            <option value="fg" ${c.action.prop === 'fg' ? 'selected' : ''}>Foreground</option>
                            <option value="bg" ${c.action.prop === 'bg' ? 'selected' : ''}>Background</option>
                        </select>
                    </div>
                    <div class="prop-group">
                        <div class="prop-label">Color</div>
                        <div class="color-palette">`;
                vgaColors.forEach(col => {
                    const selected = c.action.value === col.val ? 'border: 2px solid white;' : '';
                    html += `<div class="color-swatch" style="background: ${col.css}; ${selected}"
                             onclick="updateButtonAction('value', ${col.val})" title="${col.name}"></div>`;
                });
                html += `</div></div>`;
            }

            // Custom code editor
            if (c.action && c.action.type === 'custom') {
                html += `
                    <div class="prop-group">
                        <div class="prop-label">C Code</div>
                        <textarea class="prop-input" style="height: 120px; font-family: monospace; font-size: 11px; resize: vertical;"
                                  onchange="updateButtonAction('custom_code', this.value)"
                                  placeholder="/* Your C code here */&#10;// Example:&#10;append_digit(form, 5);">${c.action.custom_code || ''}</textarea>
                    </div>
                    <div class="prop-group">
                        <div style="font-size: 10px; color: #888; margin-top: 5px;">
                            Available: form, ctrl_set_text(), ctrl_get_text(), ctrl_set_image(),
                            ctrl_set_checked(), ctrl_get_checked(), ctrl_set_visible(),
                            ctrl_set_fg(), ctrl_set_bg(), sys_win_draw()
                        </div>
                    </div>
                `;
            }

            document.getElementById('prop-content').innerHTML = html;
        }

        function updateButtonAction(field, value) {
            if (!selectedControl || selectedControl.type !== 'button') return;

            if (!selectedControl.action) {
                selectedControl.action = { type: 'none', target: '', source_id: 0, target_id: 0, value: '', prop: 'fg', custom_code: '' };
            }

            if (field === 'type') {
                // Preserve custom_code when switching to/from custom type
                const oldCustomCode = selectedControl.action.custom_code || '';
                // Reset action fields when type changes
                selectedControl.action = {
                    type: value,
                    target: '',
                    source_id: 0,
                    target_id: 0,
                    value: value === 'set_visible' ? 1 : '',
                    prop: 'fg',
                    custom_code: value === 'custom' ? oldCustomCode : ''
                };
            } else {
                selectedControl.action[field] = value;
            }

            updateProperties();
        }

        function deleteSelected() {
            if (!selectedControl) return;
            const win = getCurrentWindow();
            if (!win) return;

            saveUndoState();

            const idx = win.controls.indexOf(selectedControl);
            if (idx > -1) {
                win.controls[idx].el.remove();
                win.controls.splice(idx, 1);
                selectedControl = null;
                updateProperties();
                updateWindowsList();
            }
        }

        function clearAllControls() {
            const win = getCurrentWindow();
            if (!win) return;

            if (confirm('Clear all controls in this window?')) {
                saveUndoState();

                win.controls.forEach(c => c.el.remove());
                win.controls = [];
                win.nextControlId = 1;
                selectedControl = null;
                updateProperties();
                updateWindowsList();
            }
        }

        // Create a hidden canvas for text measurement
        const measureCanvas = document.createElement('canvas');
        const measureCtx = measureCanvas.getContext('2d');

        // Measure text using Canvas API with Liberation Sans font
        function measureTextWidth(text, fontSize, fontType) {
            const fontWeights = ['normal', 'bold', 'normal', 'bold'];
            const fontStyles = ['normal', 'normal', 'italic', 'italic'];

            const weight = fontWeights[fontType] || 'normal';
            const style = fontStyles[fontType] || 'normal';

            measureCtx.font = `${style} ${weight} ${fontSize}px 'Liberation Sans', Arial, sans-serif`;

            let totalWidth = 0;
            for (let i = 0; i < text.length; i++) {
                const metrics = measureCtx.measureText(text[i]);
                totalWidth += Math.ceil(metrics.width);
            }

            return totalWidth;
        }

        // Calculate label dimensions based on text, font type and size
        function calculateLabelDimensions(control) {
            if (control.type !== 'label') {
                return { w: control.w, h: control.h };
            }

            const text = control.text;
            const fontSize = control.font_size || 12;

            // Split by \n to get lines
            const lines = text.split('\\n');

            // For single-line labels, return 0,0 to let osLET calculate dimensions automatically
            if (lines.length === 1) {
                return { w: 0, h: 0 };
            }

            // For multi-line labels, calculate dimensions
            let maxLineWidth = 0;
            lines.forEach(line => {
                const lineWidth = measureTextWidth(line, fontSize, control.font_type);
                if (lineWidth > maxLineWidth) {
                    maxLineWidth = lineWidth;
                }
            });

            // Font height calculation (matches osLET's font_height + spacing)
            const fontHeight = fontSize;

            const textHeight = fontHeight + ((lines.length) * (fontHeight + 2)) + 4;

            return {
                w: Math.max(maxLineWidth + 4, 10), // +4 for padding (2px on each side)
                h: textHeight
            };
        }

        function generateCode() {
            if (project.windows.length === 0) {
                alert('Add at least one window first!');
                return;
            }

            saveCurrentWindowState();

            let code = `/* Generated by osLET IDE */\n/* Project: ${project.name} */\n\n`;
            code += `#include "../syscall.h"\n`;
            code += `#include "../lib/stdio.h"\n`;
            code += `#include "../lib/string.h"\n\n`;

            // Add global variables if defined
            if (project.globals && project.globals.trim()) {
                code += `/* Global variables */\n`;
                code += project.globals.trim() + '\n\n';
            }

            // Generate static form pointers
            project.windows.forEach(win => {
                code += `static void *${win.name} = 0;\n`;
            });
            code += '\n';

            // Add helper functions if defined
            if (project.helpers && project.helpers.trim()) {
                code += `/* Helper functions */\n`;
                code += project.helpers.trim() + '\n\n';
            }

            // Generate controls for each window
            project.windows.forEach((win, winIdx) => {
                if (win.controls.length > 0) {
                    code += `// Controls for ${win.name}\n`;
                    code += `static gui_control_t ${win.name}_controls[] = {\n`;

                    win.controls.forEach((c, i) => {
                        const typeMap = {
                            'button': 'CTRL_BUTTON',
                            'label': 'CTRL_LABEL',
                            'picturebox': 'CTRL_PICTUREBOX',
                            'checkbox': 'CTRL_CHECKBOX',
                            'radiobutton': 'CTRL_RADIOBUTTON',
                            'textbox': 'CTRL_TEXTBOX',
                            'frame': 'CTRL_FRAME',
                            'dropdown': 'CTRL_DROPDOWN',
                            'scrollbar': 'CTRL_SCROLLBAR'
                        };
                        const typeStr = typeMap[c.type] || 'CTRL_BUTTON';
                        const comma = i < win.controls.length - 1 ? ',' : '';

                        // Calculate proper dimensions for labels
                        // Only auto-calculate if both w and h are 0 (unset)
                        let w = c.w;
                        let h = c.h;
                        if (c.type === 'label' && c.w === 0 && c.h === 0) {
                            const dims = calculateLabelDimensions(c);
                            w = dims.w;
                            h = dims.h;
                        }

                        const checked = c.checked || 0;
                        const group_id = c.group_id || 0;
                        const max_length = c.max_length || 0;
                        // For dropdown, count items (separated by |)
                        const item_count = c.type === 'dropdown' ? (c.text.split('|').length) : 0;
                        // Use designated initializers to match current gui_control_t layout
                        code += `    { .type = ${typeStr}, .x = ${c.x}, .y = ${c.y}, .w = ${w}, .h = ${h}, .fg = ${c.fg}, .bg = ${c.bg}, .text = "${c.text}", .id = ${c.id}, .font_type = ${c.font_type}, .font_size = ${c.font_size}, .border = ${c.border}, .border_color = ${c.border_color}, .cached_bitmap_orig = NULL, .cached_bitmap_scaled = NULL, .pressed = 0, .checked = ${checked}, .group_id = ${group_id}, .cursor_pos = 0, .max_length = ${max_length}, .scroll_offset = 0, .is_focused = 0, .sel_start = -1, .sel_end = -1, .dropdown_open = 0, .item_count = ${item_count}, .hovered_item = -1 }${comma}\n`;
                    });

                    code += `};\n\n`;
                }
            });

            // Generate event handlers for each window
            project.windows.forEach((win, winIdx) => {
                code += `static int ${win.name}_handle_event(void *form, int event, void *userdata) {\n`;
                code += `    (void)userdata;\n`;
                code += `    if (event == -1 || event == -2) {\n`;
                code += `        sys_win_draw(form);\n`;
                code += `        sys_win_redraw_all();\n`;
                code += `        return 0;\n`;
                code += `    }\n`;
                code += `    if (event > 0) {\n`;
                code += `        switch (event) {\n`;

                const buttons = win.controls.filter(c => c.type === 'button');
                if (buttons.length > 0) {
                    buttons.forEach(c => {
                        code += `            case ${c.id}: /* ${c.text} */\n`;

                        if (c.action && c.action.type !== 'none') {
                            switch (c.action.type) {
                                case 'show_form':
                                    if (c.action.target) {
                                        code += `                sys_win_draw(${c.action.target});\n`;
                                    }
                                    break;
                                case 'hide_form':
                                    if (c.action.target) {
                                        code += `                sys_win_destroy_form(${c.action.target});\n`;
                                    }
                                    break;
                                case 'exit':
                                    code += `                return 1;\n`;
                                    break;
                                case 'copy_text':
                                    if (c.action.source_id && c.action.target_id) {
                                        code += `                ctrl_set_text(form, ${c.action.target_id}, ctrl_get_text(form, ${c.action.source_id}));\n`;
                                        code += `                sys_win_draw(form);\n`;
                                    }
                                    break;
                                case 'set_text':
                                    if (c.action.target_id) {
                                        code += `                ctrl_set_text(form, ${c.action.target_id}, "${c.action.value || ''}");\n`;
                                        code += `                sys_win_draw(form);\n`;
                                    }
                                    break;
                                case 'set_image':
                                    if (c.action.source_id && c.action.target_id) {
                                        code += `                ctrl_set_image(form, ${c.action.target_id}, ctrl_get_text(form, ${c.action.source_id}));\n`;
                                        code += `                sys_win_draw(form);\n`;
                                    }
                                    break;
                                case 'toggle_checked':
                                    if (c.action.target_id) {
                                        code += `                ctrl_set_checked(form, ${c.action.target_id}, !ctrl_get_checked(form, ${c.action.target_id}));\n`;
                                        code += `                sys_win_draw(form);\n`;
                                    }
                                    break;
                                case 'set_visible':
                                    if (c.action.target_id) {
                                        code += `                ctrl_set_visible(form, ${c.action.target_id}, ${c.action.value});\n`;
                                        code += `                sys_win_draw(form);\n`;
                                    }
                                    break;
                                case 'set_color':
                                    if (c.action.target_id && c.action.value !== undefined) {
                                        const colorFunc = c.action.prop === 'bg' ? 'ctrl_set_bg' : 'ctrl_set_fg';
                                        code += `                ${colorFunc}(form, ${c.action.target_id}, ${c.action.value});\n`;
                                        code += `                sys_win_draw(form);\n`;
                                    }
                                    break;
                                case 'custom':
                                    if (c.action.custom_code) {
                                        const lines = c.action.custom_code.split('\n');
                                        lines.forEach(line => {
                                            code += `                ${line}\n`;
                                        });
                                    }
                                    break;
                                default:
                                    code += `                /* TODO: Handle ${c.text} click */\n`;
                            }
                        } else {
                            code += `                /* TODO: Handle ${c.text} click */\n`;
                        }

                        code += `                break;\n`;
                    });
                }

                code += `        }\n`;
                code += `    }\n`;
                code += `    return 0;\n`;
                code += `}\n\n`;
            });

            // Generate main function
            code += `__attribute__((section(".entry"), used))\n`;
            code += `void _start(void) {\n`;

            // Create all windows
            project.windows.forEach(win => {
                code += `    ${win.name} = sys_win_create_form("${win.title}", ${win.x}, ${win.y}, ${win.w}, ${win.h});\n`;
                code += `    if (!${win.name}) {\n`;
                code += `        sys_exit();\n`;
                code += `        return;\n`;
                code += `    }\n`;
                if (win.icon && win.icon.trim()) {
                    code += `    sys_win_set_icon(${win.name}, "${win.icon}");\n`;
                }
                if (win.controls.length > 0) {
                    code += `    for (int i = 0; i < ${win.controls.length}; i++) {\n`;
                    code += `        sys_win_add_control(${win.name}, &${win.name}_controls[i]);\n`;
                    code += `    }\n`;
                }
                code += `    sys_win_draw(${win.name});\n\n`;
            });

            code += `    sys_win_force_full_redraw();\n\n`;

            // If we have a single window, use the new helper function
            if (project.windows.length === 1) {
                const w = project.windows[0];
                code += `    sys_win_run_event_loop(${w.name}, ${w.name}_handle_event, NULL);\n\n`;
            } else {
                code += `    /* Multi-window fallback: pump each window and dispatch to generated handlers */\n`;
                code += `    int running = 1;\n`;
                code += `    while (running) {\n`;

                project.windows.forEach((win, idx) => {
                    code += `        int ev${idx} = sys_win_pump_events(${win.name});\n`;
                    code += `        if (ev${idx} == -3) { running = 0; continue; }\n`;
                    code += `        if (ev${idx} == -1 || ev${idx} == -2) { sys_win_draw(${win.name}); sys_win_redraw_all(); }\n`;
                    code += `        if (ev${idx} > 0) { if (${win.name}_handle_event(${win.name}, ev${idx}, NULL)) { running = 0; continue; } }\n\n`;
                });

                code += `        sys_yield();\n`;
                code += `    }\n\n`;
            }

            // Cleanup
            project.windows.forEach(win => {
                code += `    sys_win_destroy_form(${win.name});\n`;
            });

            code += `    sys_exit();\n`;
            code += `}\n`;

            document.getElementById('code-text').textContent = code;
            document.getElementById('code-output').classList.add('show');
        }

        function copyCode() {
            const text = document.getElementById('code-text').textContent;
            navigator.clipboard.writeText(text).then(() => {
                alert('Code copied to clipboard!');
            });
        }

        function saveCodeToFile() {
            const code = document.getElementById('code-text').textContent;
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = project.name.toLowerCase().replace(/\s+/g, '_') + '.c';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function closeCodeWindow() {
            document.getElementById('code-output').classList.remove('show');
        }

        function openCodeEditor() {
            document.getElementById('globals-editor').value = project.globals || '';
            document.getElementById('helpers-editor').value = project.helpers || '';
            document.getElementById('code-editor-modal').style.display = 'block';
        }

        function closeCodeEditor() {
            document.getElementById('code-editor-modal').style.display = 'none';
        }

        function saveCodeEditor() {
            project.globals = document.getElementById('globals-editor').value;
            project.helpers = document.getElementById('helpers-editor').value;
            closeCodeEditor();
        }

        function saveProject() {
            saveCurrentWindowState();

            const projectData = {
                name: project.name,
                globals: project.globals || '',
                helpers: project.helpers || '',
                grid: project.grid || { size: gridSize, snap: snapToGrid, show: showGrid },
                windows: project.windows.map(win => ({
                    name: win.name,
                    title: win.title,
                    icon: win.icon || '',
                    x: win.x,
                    y: win.y,
                    w: win.w,
                    h: win.h,
                    controls: win.controls.map(c => ({
                        type: c.type,
                        x: c.x,
                        y: c.y,
                        w: c.w,
                        h: c.h,
                        fg: c.fg,
                        bg: c.bg,
                        text: c.text,
                        id: c.id,
                        font_type: c.font_type,
                        font_size: c.font_size,
                        border: c.border,
                        border_color: c.border_color,
                        action: c.action
                    })),
                    nextControlId: win.nextControlId
                }))
            };

            const json = JSON.stringify(projectData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = project.name.toLowerCase().replace(/\s+/g, '_') + '.oplet';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadProject() {
            document.getElementById('project-file-input').click();
        }

        function handleProjectLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    project = {
                        name: data.name || 'Untitled Project',
                        globals: data.globals || '',
                        helpers: data.helpers || '',
                        grid: data.grid || { size: 8, snap: true, show: true },
                        windows: data.windows.map(win => ({
                            name: win.name,
                            title: win.title,
                            icon: win.icon || '',
                            x: win.x,
                            y: win.y,
                            w: win.w,
                            h: win.h,
                            controls: (win.controls || []).map(c => ({
                                ...c,
                                action: c.action ? {
                                    type: c.action.type || 'none',
                                    target: c.action.target || '',
                                    source_id: c.action.source_id || 0,
                                    target_id: c.action.target_id || 0,
                                    value: c.action.value !== undefined ? c.action.value : '',
                                    prop: c.action.prop || 'fg',
                                    custom_code: c.action.custom_code || ''
                                } : { type: 'none', target: '', source_id: 0, target_id: 0, value: '', prop: 'fg', custom_code: '' }
                            })),
                            nextControlId: win.nextControlId || 1
                        }))
                    };

                    document.getElementById('project-name').textContent = project.name;
                    currentWindowIndex = -1;

                    // Restore grid UI
                    const gridInput = document.getElementById('grid-size-input');
                    const snapChk = document.getElementById('snap-checkbox');
                    const showChk = document.getElementById('show-grid-checkbox');
                    if (gridInput) gridInput.value = (project.grid && project.grid.size) ? project.grid.size : 8;
                    if (snapChk) snapChk.checked = !!(project.grid && project.grid.snap);
                    if (showChk) showChk.checked = !!(project.grid && project.grid.show);
                    setGridFromUI();

                    updateWindowsList();

                    if (project.windows.length > 0) {
                        selectWindow(0);
                    } else {
                        hideCanvas();
                    }

                    alert('Project loaded successfully!');
                } catch (err) {
                    alert('Error loading project: ' + err.message);
                    console.error(err);
                }
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        function importCFile() {
            document.getElementById('c-file-input').click();
        }

        function handleCFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const code = e.target.result;
                parseCFileAndLoadWindows(code);
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        function parseCFileAndLoadWindows(code) {
            try {
                // Extract project name from comment if exists
                const projectNameMatch = code.match(/\/\*\s*Project:\s*([^\*]+)\*\//);
                if (projectNameMatch) {
                    project.name = projectNameMatch[1].trim();
                    document.getElementById('project-name').textContent = project.name;
                }

                // Extract global variables and helper functions
                project.globals = '';
                project.helpers = '';

                // Find static variables (globals)
                const staticVarRegex = /^(static\s+(?:int|char|void|unsigned|const)\s+[^(]+;)$/gm;
                const staticVars = code.match(staticVarRegex);
                if (staticVars) {
                    project.globals = staticVars.join('\n');
                }

                // Find static functions (helpers) - everything between includes and gui_control_t
                const helperMatch = code.match(/(?:#include[^\n]+\n)+\s*([\s\S]*?)(?=\/\/\s*Controls|gui_control_t|\n\s*void\*\s+create_)/);
                if (helperMatch && helperMatch[1]) {
                    let helpers = helperMatch[1].trim();
                    // Remove static variable declarations (we already have them)
                    helpers = helpers.replace(/^static\s+(?:int|char|void|unsigned|const)\s+[^(]+;\s*$/gm, '').trim();
                    // Remove #define lines
                    helpers = helpers.replace(/^#define\s+.+$/gm, '').trim();
                    if (helpers) {
                        project.helpers = helpers;
                    }
                }

                // Find all control arrays (e.g., Form1_controls, calc_controls, or just "controls")
                // Use a more flexible regex that handles comments and various endings
                const controlArrayRegex = /gui_control_t\s+(\w+)\s*\[\]\s*=\s*\{([\s\S]*?)\n\};/g;
                const controlMatches = [...code.matchAll(controlArrayRegex)];
                console.log('Found control arrays:', controlMatches.map(m => m[1]));

                // Try to find window creation functions first (old multi-window format with create_ functions)
                const windowFuncRegex = /void\*\s+create_(\w+)\(void\)\s*\{[\s\S]*?sys_win_create_form\("([^"]+)",\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)\)/g;
                let windowMatches = [...code.matchAll(windowFuncRegex)];
                console.log('Found window functions:', windowMatches.map(m => m[1]));

                // If no creation functions found, try new inline format (varname = sys_win_create_form)
                if (windowMatches.length === 0) {
                    // New format: form = sys_win_create_form("Title", x, y, w, h);
                    // Support both numeric literals and #define constants
                    const newFormatRegex = /(\w+)\s*=\s*sys_win_create_form\s*\(\s*"([^"]+)"\s*,\s*(\w+)\s*,\s*(\w+)\s*,\s*(\w+)\s*,\s*(\w+)\s*\)/g;
                    const newFormatMatches = [...code.matchAll(newFormatRegex)];

                    // Helper to resolve #define constants or return numeric value
                    const resolveValue = (val) => {
                        if (/^\d+$/.test(val)) return parseInt(val);
                        // Look for #define in code
                        const defineRegex = new RegExp('#define\\s+' + val + '\\s+(\\d+)');
                        const defineMatch = code.match(defineRegex);
                        return defineMatch ? parseInt(defineMatch[1]) : 100; // default fallback
                    };

                    if (newFormatMatches.length > 0) {
                        windowMatches = newFormatMatches.map(match => {
                            return [
                                match[0],
                                match[1],  // variable name as window name
                                match[2],  // title
                                resolveValue(match[3]),  // x (resolved from constant or literal)
                                resolveValue(match[4]),  // y
                                resolveValue(match[5]),  // w
                                resolveValue(match[6])   // h
                            ];
                        });
                        console.log('Found new format windows:', windowMatches.map(m => m[1]));
                    } else {
                        // Fallback: simple inline format without variable assignment
                        // Support both numeric literals and #define constants
                        const inlineRegex = /sys_win_create_form\("([^"]+)",\s*(\w+),\s*(\w+),\s*(\w+),\s*(\w+)\)/g;
                        const inlineMatches = [...code.matchAll(inlineRegex)];

                        if (inlineMatches.length === 0) {
                            alert('No window creation found in C file');
                            return;
                        }

                        // Helper to resolve #define constants (needed here if newFormatMatches was empty)
                        const resolveValueFallback = (val) => {
                            if (/^\d+$/.test(val)) return parseInt(val);
                            const defineRegex = new RegExp('#define\\s+' + val + '\\s+(\\d+)');
                            const defineMatch = code.match(defineRegex);
                            return defineMatch ? parseInt(defineMatch[1]) : 100;
                        };

                        // Convert inline format to window format
                        windowMatches = inlineMatches.map((match, idx) => {
                            return [
                                match[0],
                                `Form${idx + 1}`, // window name
                                match[1],          // title
                                resolveValueFallback(match[2]),  // x
                                resolveValueFallback(match[3]),  // y
                                resolveValueFallback(match[4]),  // w
                                resolveValueFallback(match[5])   // h
                            ];
                        });
                    }
                }

                // Clear existing project
                project.windows = [];

                // Process each window
                windowMatches.forEach((winMatch, winIdx) => {
                    const windowName = winMatch[1];
                    const windowTitle = winMatch[2];
                    const x = parseInt(winMatch[3]);
                    const y = parseInt(winMatch[4]);
                    const w = parseInt(winMatch[5]);
                    const h = parseInt(winMatch[6]);

                    // Find corresponding controls
                    // cm[1] = array name (e.g., "calc_controls", "Form1_controls")
                    // cm[2] = array content
                    let controlsMatch = controlMatches.find(cm => {
                        const arrayName = cm[1];
                        // Match: calc_controls for calculator, Form1_controls for Form1, etc.
                        return arrayName === windowName + '_controls' ||
                               arrayName === windowName ||
                               arrayName.startsWith(windowName.substring(0, 4));  // partial match like "calc" for "calculator"
                    });

                    // If still not found and we have controls, use the first one (for single-window files)
                    if (!controlsMatch && controlMatches.length > 0 && winIdx === 0) {
                        controlsMatch = controlMatches[0];
                    }

                    // Try to find icon for this window
                    // Look for: sys_win_set_icon(windowName, "path");
                    const iconRegex = new RegExp(`sys_win_set_icon\\s*\\(\\s*${windowName}\\s*,\\s*"([^"]+)"\\s*\\)`, 'g');
                    const iconMatch = iconRegex.exec(code);
                    const windowIcon = iconMatch ? iconMatch[1] : '';

                    const win = {
                        name: windowName,
                        title: windowTitle,
                        icon: windowIcon,
                        x: x,
                        y: y,
                        w: w,
                        h: h,
                        controls: [],
                        nextControlId: 1
                    };

                    if (controlsMatch) {
                        const controlsText = controlsMatch[2];

                        // Extract #define constants from the code for expression evaluation
                        const defines = {};
                        const defineRegex = /#define\s+(\w+)\s+(\d+)/g;
                        let defMatch;
                        while ((defMatch = defineRegex.exec(code)) !== null) {
                            defines[defMatch[1]] = parseInt(defMatch[2]);
                        }

                        console.log('Defines found:', defines);

                        // Helper to evaluate simple C expressions with defines
                        function evalExpr(expr) {
                            if (!expr) return 0;
                            const origExpr = expr;
                            expr = expr.trim();
                            // If it's just a number, return it
                            if (/^\d+$/.test(expr)) return parseInt(expr);
                            // Replace defined constants
                            for (const [name, val] of Object.entries(defines)) {
                                expr = expr.replace(new RegExp('\\b' + name + '\\b', 'g'), val);
                            }
                            // Try to evaluate the expression (safe since we control the input)
                            try {
                                // Only allow numbers, operators, and parentheses
                                if (/^[\d\s+\-*\/()]+$/.test(expr)) {
                                    const result = Math.floor(eval(expr));
                                    console.log(`evalExpr: "${origExpr}" -> "${expr}" = ${result}`);
                                    return result;
                                }
                            } catch (e) {
                                console.error('evalExpr error:', e, 'expr:', expr);
                            }
                            console.warn('evalExpr failed for:', origExpr, '->', expr);
                            return 0;
                        }

                        // Parse controls by finding each {CTRL_...} block
                        // This handles comments between controls properly
                        const controls = [];

                        // Find each control definition - match balanced braces starting with CTRL_
                        const controlStrings = [];
                        const ctrlRegex = /\{\s*(CTRL_\w+)/g;
                        let match;
                        while ((match = ctrlRegex.exec(controlsText)) !== null) {
                            // Find matching closing brace
                            let depth = 1;
                            let end = match.index + 1;
                            while (depth > 0 && end < controlsText.length) {
                                if (controlsText[end] === '{') depth++;
                                if (controlsText[end] === '}') depth--;
                                end++;
                            }
                            const ctrlStr = controlsText.substring(match.index + 1, end - 1).trim();
                            controlStrings.push(ctrlStr);
                        }

                        console.log('Found', controlStrings.length, 'control strings');
                        console.log('First control:', controlStrings[0]?.substring(0, 80));

                        controlStrings.forEach(ctrlStr => {
                            // Two initializer styles are supported:
                            // 1) positional: { CTRL_BUTTON, x, y, w, h, fg, bg, "text", id, ... }
                            // 2) designated: { .type = CTRL_BUTTON, .x = 10, .y = 10, .text = "...", .id = ID_FOO, ... }

                            // Prefer field-based parsing when designated initializers are used
                            if (/\=\s*/.test(ctrlStr)) {
                                // Parse .field = value pairs and quoted strings
                                const fieldRegex = /(?:\.?)(\w+)\s*=\s*(?:"((?:[^"\\]|\\.)*)"|([^,}]+))/g;
                                const fields = {};
                                let fm;
                                while ((fm = fieldRegex.exec(ctrlStr)) !== null) {
                                    const key = fm[1];
                                    const val = fm[2] !== undefined ? fm[2] : (fm[3] !== undefined ? fm[3].trim() : '');
                                    fields[key] = val;
                                }

                                const typeStr = fields['type'] || (ctrlStr.match(/(CTRL_\w+)/) || [null])[0];
                                const text = fields['text'] !== undefined ? fields['text'] : '';
                                const item_count = parseInt(fields['item_count'] || '0');
                                const checked = parseInt(fields['checked'] || '0');
                                const group_id = parseInt(fields['group_id'] || '0');
                                const max_length = parseInt(fields['max_length'] || (typeStr === 'CTRL_TEXTBOX' ? '255' : '0'));

                                controls.push([
                                    ctrlStr,
                                    typeStr,
                                    String(evalExpr(fields['x'] || '0')),
                                    String(evalExpr(fields['y'] || '0')),
                                    String(evalExpr(fields['w'] || '0')),
                                    String(evalExpr(fields['h'] || '0')),
                                    String(parseInt(fields['fg'] || '0')),
                                    String(parseInt(fields['bg'] || '0')),
                                    text,
                                    String(evalExpr(fields['id'] || '0')),
                                    String(parseInt(fields['font_type'] || '0')),
                                    String(parseInt(fields['font_size'] || '12')),
                                    String(parseInt(fields['border'] || '0')),
                                    String(parseInt(fields['border_color'] || '0')),
                                    String(parseInt(fields['checked'] || '0')),
                                    String(parseInt(fields['group_id'] || '0')),
                                    String(parseInt(fields['max_length'] || (typeStr === 'CTRL_TEXTBOX' ? '255' : '0')))
                                ]);

                            } else {
                                // Fallback: positional parsing (legacy format)
                                // Parse: TYPE, x, y, w, h, fg, bg, "text", id, font_type, font_size, border, border_color, ...
                                const typeMatch = ctrlStr.match(/^(CTRL_\w+)/);
                                if (!typeMatch) return;

                                // Extract the text field first (it's in quotes)
                                const textMatch = ctrlStr.match(/"((?:[^"\\]|\\.)*)"/);
                                const text = textMatch ? textMatch[1] : '';

                                // Split by comma, but be smart about parentheses
                                const parts = [];
                                let current = '';
                                let parenDepth = 0;
                                let inQuotes = false;

                                for (const ch of ctrlStr) {
                                    if (ch === '"' && current.slice(-1) !== '\\') inQuotes = !inQuotes;
                                    if (!inQuotes) {
                                        if (ch === '(') parenDepth++;
                                        if (ch === ')') parenDepth--;
                                        if (ch === ',' && parenDepth === 0) {
                                            parts.push(current.trim());
                                            current = '';
                                            continue;
                                        }
                                    }
                                    current += ch;
                                }
                                if (current.trim()) parts.push(current.trim());

                                // parts[0] = type, [1]=x, [2]=y, [3]=w, [4]=h, [5]=fg, [6]=bg, [7]=text, [8]=id, ...
                                console.log('Control parts:', parts.length, 'type:', parts[0], 'text:', text);
                                if (parts.length < 13) {
                                    console.warn('Skipping control with insufficient parts:', parts.length, ctrlStr.substring(0, 60));
                                }
                                if (parts.length >= 13) {
                                    // gui_control_t struct fields:
                                    // 0=type, 1=x, 2=y, 3=w, 4=h, 5=fg, 6=bg, 7=text, 8=id,
                                    // 9=font_type, 10=font_size, 11=border, 12=border_color,
                                    // 13=cached_bitmap, 14=pressed, 15=checked, 16=group_id,
                                    // 17=cursor_pos, 18=max_length, 19=scroll_offset, 20=is_focused, 21=sel_start, 22=sel_end
                                    controls.push([
                                        ctrlStr,           // [0] full match (not used)
                                        parts[0],          // [1] type
                                        parts[1],          // [2] x
                                        parts[2],          // [3] y
                                        parts[3],          // [4] w
                                        parts[4],          // [5] h
                                        parts[5],          // [6] fg
                                        parts[6],          // [7] bg
                                        text,              // [8] text (extracted from quotes)
                                        parts[8],          // [9] id
                                        parts[9],          // [10] font_type
                                        parts[10],         // [11] font_size
                                        parts[11],         // [12] border
                                        parts[12],         // [13] border_color
                                        parts[15] || '0',  // [14] checked (struct index 15)
                                        parts[16] || '0',  // [15] group_id (struct index 16)
                                        parts[18] || '0'   // [16] max_length (struct index 18)
                                    ]);
                                }
                            }
                        });

                        console.log('Parsed', controls.length, 'controls');

                        controls.forEach(match => {
                            const typeStr = match[1];
                            const typeMap = {
                                'CTRL_BUTTON': 'button',
                                'CTRL_LABEL': 'label',
                                'CTRL_PICTUREBOX': 'picturebox',
                                'CTRL_CHECKBOX': 'checkbox',
                                'CTRL_RADIOBUTTON': 'radiobutton',
                                'CTRL_TEXTBOX': 'textbox',
                                'CTRL_FRAME': 'frame',
                                'CTRL_DROPDOWN': 'dropdown',
                                'CTRL_SCROLLBAR': 'scrollbar'
                            };
                            const type = typeMap[typeStr] || 'button';

                            const control = {
                                type: type,
                                x: evalExpr(match[2]),
                                y: evalExpr(match[3]),
                                w: evalExpr(match[4]),
                                h: evalExpr(match[5]),
                                fg: parseInt(match[6]) || 0,
                                bg: parseInt(match[7]) || 0,
                                text: match[8],
                                id: evalExpr(match[9]),
                                font_type: parseInt(match[10]) || 0,
                                font_size: parseInt(match[11]) || 12,
                                border: parseInt(match[12]) || 0,
                                border_color: parseInt(match[13]) || 0,
                                checked: parseInt(match[14]) || 0,
                                group_id: parseInt(match[15]) || 0,
                                max_length: parseInt(match[16]) || (type === 'textbox' ? 255 : 0),
                                action: type === 'button' ? { type: 'none', target: '', source_id: 0, target_id: 0, value: '', prop: 'fg', custom_code: '' } : undefined
                            };

                            console.log(`Parsed ${type} id=${control.id}: x=${control.x}, y=${control.y}, w=${control.w}, h=${control.h}`);

                            if (control.id >= win.nextControlId) {
                                win.nextControlId = control.id + 1;
                            }

                            // Try to parse button actions from code
                            if (type === 'button') {
                                parseButtonAction(code, windowName, control);
                            }

                            win.controls.push(control);
                        });
                    } else {
                        // Alternative parser: dynamic control creation format
                        // Handles: gui_control_t varname = {0}; varname.type = ...; sys_win_add_control(form, &varname);
                        console.log('No static control array found, trying dynamic format parser...');

                        // Extract #define constants from the code
                        const defines = {};
                        const defineRegex = /#define\s+(\w+)\s+(\d+)/g;
                        let defMatch;
                        while ((defMatch = defineRegex.exec(code)) !== null) {
                            defines[defMatch[1]] = parseInt(defMatch[2]);
                        }

                        // Helper to evaluate expressions with defines
                        function evalExprDyn(expr) {
                            if (!expr) return 0;
                            expr = expr.trim();
                            if (/^\d+$/.test(expr)) return parseInt(expr);
                            // Check if it's a defined constant
                            if (defines[expr] !== undefined) return defines[expr];
                            // Replace defined constants in expression
                            for (const [name, val] of Object.entries(defines)) {
                                expr = expr.replace(new RegExp('\\b' + name + '\\b', 'g'), val);
                            }
                            try {
                                if (/^[\d\s+\-*\/()]+$/.test(expr)) {
                                    return Math.floor(eval(expr));
                                }
                            } catch (e) {}
                            return 0;
                        }

                        // Find each control block: from "gui_control_t varname" to "sys_win_add_control(..., &varname)"
                        // This handles repeated variable names correctly by parsing each block independently
                        const controlBlockRegex = /gui_control_t\s+(\w+)\s*=\s*\{0\}\s*;([\s\S]*?)sys_win_add_control\s*\([^,]+,\s*&\1\s*\)/g;
                        let blockMatch;

                        while ((blockMatch = controlBlockRegex.exec(code)) !== null) {
                            const varName = blockMatch[1];
                            const blockCode = blockMatch[2];

                            const control = {
                                type: 'button',
                                x: 0, y: 0, w: 80, h: 24,
                                fg: 0, bg: 7,
                                text: '',
                                id: 0,
                                font_type: 0, font_size: 12,
                                border: 0, border_color: 0,
                                checked: 0, group_id: 0, max_length: 0
                            };

                            // Extract field assignments within this block only: varname.field = value;
                            const fieldRegex = new RegExp(varName + '\\.(\\w+)\\s*=\\s*([^;]+);', 'g');
                            let fieldMatch;
                            while ((fieldMatch = fieldRegex.exec(blockCode)) !== null) {
                                const field = fieldMatch[1];
                                let value = fieldMatch[2].trim();

                                switch (field) {
                                    case 'type':
                                        const typeMap = {
                                            'CTRL_BUTTON': 'button',
                                            'CTRL_LABEL': 'label',
                                            'CTRL_PICTUREBOX': 'picturebox',
                                            'CTRL_CHECKBOX': 'checkbox',
                                            'CTRL_RADIOBUTTON': 'radiobutton',
                                            'CTRL_TEXTBOX': 'textbox',
                                            'CTRL_FRAME': 'frame',
                                            'CTRL_DROPDOWN': 'dropdown',
                                            'CTRL_SCROLLBAR': 'scrollbar'
                                        };
                                        control.type = typeMap[value] || 'button';
                                        break;
                                    case 'x': control.x = evalExprDyn(value); break;
                                    case 'y': control.y = evalExprDyn(value); break;
                                    case 'w': control.w = evalExprDyn(value); break;
                                    case 'h': control.h = evalExprDyn(value); break;
                                    case 'fg': control.fg = evalExprDyn(value); break;
                                    case 'bg': control.bg = evalExprDyn(value); break;
                                    case 'id': control.id = evalExprDyn(value); break;
                                    case 'font_type': control.font_type = evalExprDyn(value); break;
                                    case 'font_size': control.font_size = evalExprDyn(value); break;
                                    case 'border': control.border = evalExprDyn(value); break;
                                    case 'border_color': control.border_color = evalExprDyn(value); break;
                                    case 'checked': control.checked = evalExprDyn(value); break;
                                    case 'group_id': control.group_id = evalExprDyn(value); break;
                                    case 'max_length': control.max_length = evalExprDyn(value); break;
                                    case 'item_count': control.item_count = evalExprDyn(value); break;
                                    case 'cursor_pos': control.cursor_pos = evalExprDyn(value); break;
                                }
                            }

                            // Extract text from strcpy/strncpy calls within this block
                            const strcpyRegex = new RegExp(`strn?cpy\\s*\\(\\s*${varName}\\.text\\s*,\\s*"([^"]*)"`, 'g');
                            const strcpyMatch = strcpyRegex.exec(blockCode);
                            if (strcpyMatch) {
                                control.text = strcpyMatch[1];
                            }

                            // Add button action placeholder
                            if (control.type === 'button') {
                                control.action = { type: 'none', target: '', source_id: 0, target_id: 0, value: '', prop: 'fg', custom_code: '' };
                                parseButtonAction(code, windowName, control);
                            }

                            if (control.id >= win.nextControlId) {
                                win.nextControlId = control.id + 1;
                            }

                            console.log(`Parsed dynamic ${control.type} id=${control.id}: "${control.text}" at (${control.x},${control.y}) ${control.w}x${control.h}`);
                            win.controls.push(control);
                        }
                    }

                    project.windows.push(win);
                });

                updateWindowsList();

                if (project.windows.length > 0) {
                    selectWindow(0);
                } else {
                    hideCanvas();
                }

                const totalControls = project.windows.reduce((sum, w) => sum + w.controls.length, 0);
                alert(`Imported ${project.windows.length} window(s) with ${totalControls} control(s)!`);

            } catch (err) {
                alert('Error parsing C file: ' + err.message);
                console.error(err);
            }
        }

        function parseButtonAction(code, windowName, control) {
            // Find the event handler block for this button
            // Match patterns like: if (event0 == 2) { ... } or case ID_BTN_X: ... break;

            let actionCode = '';

            // Try if-style first: if (event0 == 17) { ... }
            const ifPattern = new RegExp(
                `if\\s*\\(event\\d*\\s*==\\s*${control.id}\\)\\s*\\{([^}]*(?:\\{[^}]*\\}[^}]*)*)\\}`,
                's'
            );
            let ifMatch = ifPattern.exec(code);
            if (ifMatch) {
                actionCode = ifMatch[1];
            }

            // Try switch-case style: case ID_BTN_7: append_digit(calc, 7); break;
            // or: case 17: append_digit(calc, 7); break;
            if (!actionCode) {
                // Find all #define ID constants to match by name
                const defineMap = {};
                const defineRegex = /#define\s+(ID_\w+)\s+(\d+)/g;
                let defMatch;
                while ((defMatch = defineRegex.exec(code)) !== null) {
                    defineMap[defMatch[2]] = defMatch[1];  // id -> name
                }

                // Look for case with this control's ID (by number or by define name)
                const idName = defineMap[String(control.id)] || String(control.id);
                console.log(`Looking for action for button ${control.id}, idName=${idName}`);

                // Try multiple patterns to find the case statement
                const casePatterns = [
                    // Match by define name: case ID_BTN_7: ...
                    new RegExp(`case\\s+${idName}\\s*:\\s*([^;]+;)(?:\\s*break;)?`, 's'),
                    // Match by numeric ID: case 17: ...
                    new RegExp(`case\\s+${control.id}\\s*:\\s*([^;]+;)(?:\\s*break;)?`, 's')
                ];

                for (const pattern of casePatterns) {
                    const caseMatch = pattern.exec(code);
                    if (caseMatch) {
                        actionCode = caseMatch[1].trim();
                        console.log(`Case match for control ${control.id} (${idName}):`, actionCode);
                        break;
                    }
                }

                if (!actionCode) {
                    console.log(`No case match found for control ${control.id} (${idName})`);
                }
            }

            // Parse recognized action patterns
            control.action = { type: 'none', target: '', source_id: 0, target_id: 0, value: '', prop: 'fg', custom_code: '' };

            // If we found action code, store it as custom
            if (actionCode && actionCode.trim()) {
                console.log(`Found action for control ${control.id}:`, actionCode.substring(0, 50));
            }

            // Check for ctrl_set_text with ctrl_get_text (copy_text)
            const copyTextMatch = actionCode.match(/ctrl_set_text\s*\(\s*\w+\s*,\s*(\d+)\s*,\s*ctrl_get_text\s*\(\s*\w+\s*,\s*(\d+)\s*\)\s*\)/);
            if (copyTextMatch) {
                control.action = {
                    type: 'copy_text',
                    target_id: parseInt(copyTextMatch[1]),
                    source_id: parseInt(copyTextMatch[2]),
                    target: '', value: '', prop: 'fg', custom_code: ''
                };
                return;
            }

            // Check for ctrl_set_text with literal string (set_text)
            const setTextMatch = actionCode.match(/ctrl_set_text\s*\(\s*\w+\s*,\s*(\d+)\s*,\s*"([^"]*)"\s*\)/);
            if (setTextMatch) {
                control.action = {
                    type: 'set_text',
                    target_id: parseInt(setTextMatch[1]),
                    value: setTextMatch[2],
                    target: '', source_id: 0, prop: 'fg', custom_code: ''
                };
                return;
            }

            // Check for ctrl_set_image
            const setImageMatch = actionCode.match(/ctrl_set_image\s*\(\s*\w+\s*,\s*(\d+)\s*,\s*ctrl_get_text\s*\(\s*\w+\s*,\s*(\d+)\s*\)\s*\)/);
            if (setImageMatch) {
                control.action = {
                    type: 'set_image',
                    target_id: parseInt(setImageMatch[1]),
                    source_id: parseInt(setImageMatch[2]),
                    target: '', value: '', prop: 'fg', custom_code: ''
                };
                return;
            }

            // Check for ctrl_set_checked (toggle)
            const toggleMatch = actionCode.match(/ctrl_set_checked\s*\(\s*\w+\s*,\s*(\d+)\s*,\s*!ctrl_get_checked/);
            if (toggleMatch) {
                control.action = {
                    type: 'toggle_checked',
                    target_id: parseInt(toggleMatch[1]),
                    target: '', source_id: 0, value: '', prop: 'fg', custom_code: ''
                };
                return;
            }

            // Check for ctrl_set_visible
            const visibleMatch = actionCode.match(/ctrl_set_visible\s*\(\s*\w+\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
            if (visibleMatch) {
                control.action = {
                    type: 'set_visible',
                    target_id: parseInt(visibleMatch[1]),
                    value: parseInt(visibleMatch[2]),
                    target: '', source_id: 0, prop: 'fg', custom_code: ''
                };
                return;
            }

            // Check for ctrl_set_fg/ctrl_set_bg (set_color)
            const colorMatch = actionCode.match(/ctrl_set_(fg|bg)\s*\(\s*\w+\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
            if (colorMatch) {
                control.action = {
                    type: 'set_color',
                    prop: colorMatch[1],
                    target_id: parseInt(colorMatch[2]),
                    value: parseInt(colorMatch[3]),
                    target: '', source_id: 0, custom_code: ''
                };
                return;
            }

            // Check for sys_win_draw (show_form)
            const showFormMatch = actionCode.match(/sys_win_draw\s*\(\s*(\w+)\s*\)/);
            if (showFormMatch && !actionCode.includes('ctrl_set_')) {
                control.action = {
                    type: 'show_form',
                    target: showFormMatch[1],
                    source_id: 0, target_id: 0, value: '', prop: 'fg', custom_code: ''
                };
                return;
            }

            // Check for hide_form
            if (actionCode.includes('sys_win_restore_background')) {
                const targetMatch = actionCode.match(/\(\(gui_form_t\*\)\s*(\w+)\s*\)/);
                control.action = {
                    type: 'hide_form',
                    target: targetMatch ? targetMatch[1] : '',
                    source_id: 0, target_id: 0, value: '', prop: 'fg', custom_code: ''
                };
                return;
            }

            // Check for exit - must have exit_requested, not just 'break' (which appears in switch/case)
            if (actionCode.includes('exit_requested')) {
                control.action = {
                    type: 'exit',
                    target: '', source_id: 0, target_id: 0, value: '', prop: 'fg', custom_code: ''
                };
                return;
            }

            // If we found code but couldn't parse it as a known action, store as custom
            if (actionCode && actionCode.trim() && !actionCode.includes('// TODO:')) {
                let cleanCode = actionCode.trim();
                // Remove trailing break; if present (from switch/case)
                cleanCode = cleanCode.replace(/;\s*break;?\s*$/, ';').trim();
                // Remove sys_win_draw calls that we handle elsewhere
                cleanCode = cleanCode.replace(/^\s*sys_win_draw\s*\(\s*\w+\s*\)\s*;?\s*$/g, '');
                cleanCode = cleanCode.trim();

                if (cleanCode) {
                    control.action = {
                        type: 'custom',
                        custom_code: cleanCode,
                        target: '', source_id: 0, target_id: 0, value: '', prop: 'fg'
                    };
                    console.log(`Stored custom action for control ${control.id}:`, cleanCode);
                }
            }
        }
    </script>
</body>
</html>